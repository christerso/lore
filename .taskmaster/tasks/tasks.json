{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Fix Vulkan semaphore validation errors in graphics system",
        "description": "Resolve validation warnings about semaphore reuse between swapchain images by implementing proper semaphore management and synchronization in the Vulkan renderer.",
        "details": "The current Vulkan renderer is experiencing validation layer warnings about improper semaphore usage across swapchain images. This needs to be fixed by:\n\n1. **Identify the validation errors**:\n   - Enable Vulkan validation layers if not already enabled\n   - Capture the exact validation messages about semaphore reuse\n   - Identify which semaphores are being improperly reused (likely imageAvailableSemaphore and renderFinishedSemaphore)\n\n2. **Implement per-frame semaphores**:\n   - Create separate semaphore sets for each frame in flight\n   - Modify the semaphore creation in VulkanContext or renderer initialization\n   - Example structure:\n   ```cpp\n   struct FrameSyncObjects {\n       VkSemaphore imageAvailableSemaphore;\n       VkSemaphore renderFinishedSemaphore;\n       VkFence inFlightFence;\n   };\n   std::vector<FrameSyncObjects> frameSync;\n   ```\n\n3. **Update frame acquisition logic**:\n   - Use the correct semaphore for the current frame index\n   - Ensure vkAcquireNextImageKHR uses the appropriate imageAvailableSemaphore\n   - Track current frame index: `currentFrame = (currentFrame + 1) % MAX_FRAMES_IN_FLIGHT`\n\n4. **Fix submit and present operations**:\n   - Update vkQueueSubmit to use frame-specific semaphores\n   - Ensure renderFinishedSemaphore signals are properly waited on by presentation\n   - Verify fence synchronization is correct for CPU-GPU sync\n\n5. **Handle swapchain recreation**:\n   - Ensure semaphores are properly cleaned up during swapchain recreation\n   - Recreate sync objects if needed when swapchain is rebuilt\n   - Add proper vkDeviceWaitIdle() calls where necessary\n\n6. **Memory management**:\n   - Properly destroy old semaphores in cleanup functions\n   - Ensure no semaphore leaks during runtime or shutdown\n   - Add validation for semaphore lifecycle\n\nKey files likely needing modification:\n- src/graphics/vulkan_context.cpp or similar Vulkan initialization code\n- src/graphics/renderer.cpp or main render loop implementation\n- Include proper synchronization in command buffer recording and submission",
        "testStrategy": "1. **Enable validation layers**: Ensure VK_LAYER_KHRONOS_validation is enabled in debug builds\n\n2. **Run validation tests**:\n   - Start the application and monitor console/debug output for validation errors\n   - Specifically look for messages containing 'VUID-vkAcquireNextImageKHR-semaphore' or similar\n   - Verify no semaphore-related validation errors appear during normal rendering\n\n3. **Stress test synchronization**:\n   - Rapidly resize the window to trigger swapchain recreation\n   - Alt-tab or minimize/restore the window multiple times\n   - Run for extended periods (5-10 minutes) to catch any timing issues\n\n4. **Frame timing verification**:\n   - Use RenderDoc or similar GPU debugger to verify proper frame boundaries\n   - Check that each frame has unique semaphores in the timeline\n   - Verify no semaphore is signaled twice without being waited on\n\n5. **Performance validation**:\n   - Ensure frame rate remains stable after fixes\n   - Monitor GPU utilization to verify no synchronization bottlenecks\n   - Use Vulkan profiling tools to check for pipeline stalls\n\n6. **Multi-frame testing**:\n   - Test with different MAX_FRAMES_IN_FLIGHT values (1, 2, 3)\n   - Verify synchronization works correctly regardless of frames in flight\n   - Ensure no visual artifacts or tearing occurs\n\n7. **Clean shutdown test**:\n   - Verify application shuts down cleanly without validation errors\n   - Check for any semaphore leak warnings in validation layers\n   - Run with memory debugging tools to ensure no Vulkan object leaks",
        "status": "done",
        "dependencies": [],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 3,
        "title": "Create .lore package creation tools and utilities",
        "description": "Implement command-line tools for building, packing, and managing .lore asset packages for distribution, including package creation, validation, extraction, and metadata management capabilities.",
        "details": "This task involves creating a comprehensive toolset for managing .lore asset packages:\n\n1. **Define .lore Package Format**:\n   - Design binary package format with header, metadata section, and compressed asset data\n   - Include version information, package UUID, creation timestamp\n   - Support for asset manifest with file paths, types, sizes, and checksums\n   - Implement compression using zstd or lz4 for optimal size/speed balance\n   - Design chunk-based structure for streaming and partial loading\n\n2. **Implement Core Package Library (lore::packages)**:\n   - Create PackageWriter class for building packages\n   - Implement PackageReader class for loading and extracting\n   - Add PackageManifest class for metadata management\n   - Support for incremental package updates and patches\n   - Implement package validation with CRC32/SHA256 checksums\n\n3. **Create Command-Line Tool (lore-pack)**:\n   - **pack** command: Build .lore packages from directory structure\n     ```bash\n     lore-pack pack ./assets -o game_assets.lore --compress=zstd --level=3\n     ```\n   - **unpack** command: Extract packages to filesystem\n     ```bash\n     lore-pack unpack game_assets.lore -o ./extracted_assets\n     ```\n   - **list** command: Display package contents\n     ```bash\n     lore-pack list game_assets.lore --verbose\n     ```\n   - **validate** command: Verify package integrity\n     ```bash\n     lore-pack validate game_assets.lore --check-checksums\n     ```\n   - **info** command: Show package metadata\n     ```bash\n     lore-pack info game_assets.lore\n     ```\n\n4. **Package Building Features**:\n   - Recursive directory scanning with glob pattern support\n   - Automatic asset type detection based on file extensions\n   - Asset preprocessing (texture compression, audio conversion)\n   - Dependency resolution for linked assets\n   - Progress reporting with ETA calculation\n   - Dry-run mode for preview\n   - Configuration file support (.lore-pack.yml)\n\n5. **Advanced Features**:\n   - **Differential Packages**: Create patch packages containing only changed assets\n   - **Package Signing**: Digital signatures for authentication\n   - **Encryption Support**: Optional AES-256 encryption for sensitive assets\n   - **Multi-part Packages**: Split large packages into multiple files\n   - **Package Merging**: Combine multiple packages into one\n   - **Hot-reload Support**: Watch mode for development\n\n6. **Integration with Asset System**:\n   - Modify AssetManager to load directly from .lore packages\n   - Implement PackageAssetSource as IAssetSource implementation\n   - Add streaming support for large assets\n   - Cache frequently accessed assets in memory\n   - Support for multiple mounted packages with priority ordering\n\n7. **Package Manifest Structure**:\n   ```cpp\n   struct PackageManifest {\n       std::string package_name;\n       std::string version;\n       std::string author;\n       uint64_t creation_time;\n       std::vector<AssetEntry> assets;\n       std::map<std::string, std::string> metadata;\n       std::vector<std::string> dependencies;\n   };\n   ```\n\n8. **Error Handling and Logging**:\n   - Comprehensive error messages for all failure modes\n   - Verbose logging modes for debugging\n   - Recovery from corrupted packages\n   - Rollback support for failed operations",
        "testStrategy": "1. **Unit Tests for Core Library**:\n   - Test PackageWriter with various asset types and sizes\n   - Verify PackageReader correctly extracts all asset types\n   - Test compression/decompression with different algorithms\n   - Validate checksum calculation and verification\n   - Test manifest serialization/deserialization\n   - Verify chunk-based reading for streaming\n\n2. **Command-Line Tool Tests**:\n   - Test pack command with sample asset directory\n   - Verify unpacked assets match original files byte-for-byte\n   - Test list command output formatting\n   - Validate info command displays correct metadata\n   - Test validate command detects corrupted packages\n   - Verify dry-run mode doesn't create files\n\n3. **Integration Tests**:\n   - Create package with mixed asset types (images, audio, models)\n   - Load package through AssetManager and verify asset access\n   - Test hot-reload functionality during development\n   - Verify multiple package mounting and priority resolution\n   - Test streaming large assets from packages\n\n4. **Performance Tests**:\n   - Measure packing time for 1GB+ of assets\n   - Compare compression ratios between algorithms\n   - Test extraction speed for various package sizes\n   - Benchmark asset loading from packages vs filesystem\n   - Measure memory usage during streaming\n\n5. **Error Handling Tests**:\n   - Test with corrupted package headers\n   - Verify handling of missing dependencies\n   - Test recovery from incomplete packages\n   - Validate error messages are informative\n   - Test with invalid command-line arguments\n\n6. **Cross-Platform Tests**:\n   - Verify packages created on Windows work on Linux/Mac\n   - Test path normalization across platforms\n   - Validate endianness handling in binary format\n\n7. **Security Tests**:\n   - Test package signing and verification\n   - Verify encrypted packages can only be read with correct key\n   - Test resistance to malicious packages (path traversal, etc.)",
        "status": "pending",
        "dependencies": [
          "2"
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 4,
        "title": "Add hot-reload file watching system for development",
        "description": "Implement filesystem monitoring to automatically reload assets when they change during development, providing instant feedback without requiring application restart.",
        "details": "This task involves implementing a comprehensive file watching system for automatic asset reloading during development:\n\n1. **Filesystem Monitoring Infrastructure**:\n   - Integrate a cross-platform file watching library (e.g., efsw, fswatch, or native platform APIs)\n   - Implement FileWatcher class with support for recursive directory watching\n   - Create event system for file change notifications (created, modified, deleted, renamed)\n   - Support for filtering by file extensions and ignore patterns (e.g., .git, build directories)\n   - Implement debouncing to handle rapid consecutive changes\n   - Thread-safe event queue for processing changes on the main thread\n\n2. **Asset Reload System**:\n   - Create AssetReloader class that interfaces with existing AssetManager\n   - Implement reload strategies for different asset types:\n     * Textures: Reload image data and update GPU resources\n     * Shaders: Recompile and relink shader programs\n     * Models: Reload geometry and update vertex buffers\n     * Audio: Reload audio data and update sound buffers\n     * Config files: Parse and apply new settings\n   - Maintain asset dependency graph for cascading reloads\n   - Implement versioning system to track asset generations\n\n3. **Integration with Asset System**:\n   - Add reload capability to existing asset loaders\n   - Implement asset state management (loading, loaded, reloading, error)\n   - Create callback system for components to respond to asset changes\n   - Add reference counting to safely reload assets in use\n   - Implement fallback mechanism for failed reloads\n\n4. **Development Mode Configuration**:\n   - Add development mode flag to enable/disable hot reload\n   - Configure watched directories via config file or command line\n   - Implement performance monitoring to track reload times\n   - Add console commands for manual reload triggers\n   - Create reload statistics display (files watched, reloads performed, errors)\n\n5. **Error Handling and Recovery**:\n   - Graceful handling of file access errors\n   - Validation of reloaded assets before replacing\n   - Rollback mechanism for failed reloads\n   - Error notification system with detailed logging\n   - Retry mechanism for temporarily locked files\n\n6. **Platform-Specific Implementations**:\n   - Windows: Use ReadDirectoryChangesW or WMI\n   - Linux: Use inotify API\n   - macOS: Use FSEvents API\n   - Fallback polling mechanism for unsupported platforms",
        "testStrategy": "1. **File Watching Tests**:\n   - Create test directory with various asset types\n   - Modify files and verify change events are triggered\n   - Test rapid file modifications for debouncing behavior\n   - Verify recursive directory watching works correctly\n   - Test file deletion and creation handling\n   - Verify ignore patterns filter correctly\n\n2. **Asset Reload Tests**:\n   - Load initial assets and record their state\n   - Modify asset files on disk\n   - Verify assets are automatically reloaded\n   - Check that GPU resources are properly updated\n   - Test that old resources are properly released\n   - Verify asset references remain valid after reload\n\n3. **Performance Tests**:\n   - Measure reload time for various asset types\n   - Test system with hundreds of watched files\n   - Verify no memory leaks during repeated reloads\n   - Check CPU usage of file watching threads\n   - Test impact on frame rate during reloads\n\n4. **Error Handling Tests**:\n   - Attempt to reload corrupted asset files\n   - Test behavior with locked or inaccessible files\n   - Verify rollback works for failed reloads\n   - Test recovery from file system errors\n   - Verify error messages are informative\n\n5. **Integration Tests**:\n   - Run application in development mode\n   - Modify shaders and verify visual changes\n   - Change textures and confirm updates in rendering\n   - Modify config files and verify settings apply\n   - Test hot reload while application is actively using assets\n\n6. **Cross-Platform Tests**:\n   - Verify file watching works on Windows, Linux, and macOS\n   - Test path handling with different separators\n   - Verify Unicode filename support\n   - Test with symbolic links and junctions",
        "status": "pending",
        "dependencies": [
          "2"
        ],
        "priority": "low",
        "subtasks": []
      },
      {
        "id": 5,
        "title": "Data Management System",
        "description": "Implement comprehensive data management system with database API, cross-reference capabilities, and structured game data",
        "details": "Create database system for weapons, armor, clothing, furniture, decorations, vehicles, tools, terrain data with multitile support and ASCII/Unicode symbol management",
        "testStrategy": "",
        "status": "pending",
        "dependencies": [],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 6,
        "title": "Entity Generation System",
        "description": "Implement advanced entity generation with biological and synthetic entities, enhancement systems, and name generation",
        "details": "Create entity generator with human composition, equipment helpers, settlement generation, biological/synthetic entity types, and enhancement structures",
        "testStrategy": "",
        "status": "pending",
        "dependencies": [],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 7,
        "title": "Advanced Physics Systems",
        "description": "Implement comprehensive physics systems including thermodynamics, electromagnetics, optics, quantum mechanics, and radioactivity",
        "details": "Create advanced physics simulation with chemistry, nuclear physics, acoustic materials, electrical systems, thermal effects, laser systems, radiation detection, and quantum computing integration",
        "testStrategy": "",
        "status": "pending",
        "dependencies": [],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 8,
        "title": "GPU Compute Systems",
        "description": "Implement specialized GPU compute systems for ballistics, fluid dynamics, chemistry, explosions, and materials simulation",
        "details": "Create GPU-accelerated compute shaders for ballistics API, fluid dynamics API, chemistry API, explosion API, materials API with GPU interop and physics core integration",
        "testStrategy": "",
        "status": "pending",
        "dependencies": [],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 9,
        "title": "Game Systems Framework",
        "description": "Implement specialized game systems for ballistics, fluids, smoke/fire simulation, and environmental effects",
        "details": "Create game-specific systems including ballistics simulation, fluid dynamics, smoke and fire effects, all integrated with ECS and GPU compute acceleration",
        "testStrategy": "",
        "status": "pending",
        "dependencies": [],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 10,
        "title": "Utilities and Tools System",
        "description": "Implement utility systems for development tools, debugging, and engine support functionality",
        "details": "Create utility framework with debugging tools, development helpers, and engine support utilities for efficient development workflow",
        "testStrategy": "",
        "status": "pending",
        "dependencies": [],
        "priority": "low",
        "subtasks": []
      },
      {
        "id": 11,
        "title": "Integrate ECS and Asset systems into main application",
        "description": "Activate the fully-implemented ECS and Asset management systems by integrating them into main.cpp. Both systems are complete but currently unused.",
        "details": "The ECS system (include/lore/ecs/ecs.hpp, src/ecs/) and Asset system (include/lore/assets/assets.hpp, src/assets/) are fully implemented with:\n- ECS: World, EntityManager, ComponentRegistry, System management, sparse set storage\n- Assets: AssetManager, VulkanImageLoader, package system, hot-reloading, streaming\n\nIntegration requirements:\n1. Uncomment ECS includes in main.cpp (line 2)\n2. Create ECS World instance\n3. Initialize Asset System with Vulkan context from GraphicsSystem\n4. Create example entities with components\n5. Add systems to World and call world.update() in game loop\n6. Demonstrate asset loading with GPU resources",
        "testStrategy": "",
        "status": "done",
        "dependencies": [],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 12,
        "title": "Implement Deferred Rendering Pipeline with PBR",
        "description": "Replace the current forward renderer with a full deferred rendering pipeline supporting physically-based rendering (PBR), multiple lights, real-time atmospheric effects, and weather simulation",
        "status": "done",
        "dependencies": [],
        "priority": "high",
        "details": "Current state: Deferred renderer 70% complete with production-ready foundation\nCompleted: G-Buffer with 5 attachments, render passes structure, light/material management systems, FULL PBR shaders (Cook-Torrance BRDF with GGX distribution, Smith geometry function, Schlick approximation), comprehensive 60-page documentation at docs/systems/deferred_rendering_status.md\n\nRemaining implementation (~550 lines total):\n- Pipeline creation for geometry and lighting passes (~250 lines)\n- Descriptor sets for uniforms and samplers (~200 lines)  \n- Lighting pass rendering logic (~100 lines)\n- Remove 7 TODO comments per project rules\n\nAll completed code is production-ready with NO shortcuts or placeholders.\n\nFuture enhancements (after core completion):\n- Shadow mapping (cascaded for directional, cube for point)\n- Screen-space ambient occlusion (SSAO)\n- Atmospheric scattering for weather/time-of-day\n- Bloom post-processing\n- HDR tone mapping operators",
        "testStrategy": "Verify G-Buffer attachments render correctly, validate PBR BRDF calculations against reference implementations, test multiple light sources, ensure pipeline state transitions are valid, benchmark performance with various light counts, validate descriptor set bindings, test with different material parameters",
        "subtasks": [
          {
            "id": 1,
            "title": "Complete pipeline creation for geometry and lighting passes",
            "description": "Implement ~250 lines of Vulkan pipeline creation code for both geometry and lighting render passes",
            "status": "pending",
            "dependencies": [],
            "details": "Create graphics pipelines with proper state configuration, vertex input descriptions, viewport/scissor setup, rasterization state, multisampling, depth/stencil testing, color blending for MRT outputs",
            "testStrategy": "",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement descriptor sets for uniforms and samplers",
            "description": "Create ~200 lines of descriptor set layouts and allocation code for binding uniforms and texture samplers",
            "status": "pending",
            "dependencies": [],
            "details": "Define descriptor set layouts for camera matrices, light data, material properties, G-Buffer samplers. Implement descriptor pool allocation and set updates. Ensure proper binding points match shader expectations",
            "testStrategy": "",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implement lighting pass rendering logic",
            "description": "Complete ~100 lines of lighting pass render code to process G-Buffer and calculate final lighting",
            "status": "pending",
            "dependencies": [],
            "details": "Implement deferred lighting pass that reads G-Buffer attachments, iterates through light sources, applies PBR BRDF calculations, and outputs final lit color. Include proper command buffer recording and synchronization",
            "testStrategy": "",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Remove TODO comments and implement remaining stubs",
            "description": "Eliminate all 7 TODO comments in the codebase by implementing the remaining functionality",
            "status": "pending",
            "dependencies": [],
            "details": "Locate and address each TODO comment with full implementation per project rules - no placeholders or simplifications allowed. Ensure all code paths are complete and production-ready",
            "testStrategy": "",
            "parentId": "undefined"
          }
        ],
        "updatedAt": "2025-09-29T21:32:07.026Z"
      },
      {
        "id": 13,
        "title": "Implement 3D Tilemap System for World Generation",
        "description": "Create a 3D tilemap-based world system that uses tile definitions to spawn 3D meshes/objects for walls, floors, and entities. Tiles map to 3D models with optional textures.",
        "details": "System design:\n- Tilemap data structure (grid-based, supports multiple layers)\n- Tile definitions database (JSON/binary format)\n- Tile-to-3D-mesh mapping system\n- Automatic mesh instancing for performance\n- Support for multi-tile objects (2x2, 3x3 structures)\n- Player-controlled entity with camera\n- Initial tile set: walls, floors, doors, basic objects\n- Integration with ECS for tile entities\n- Chunk-based loading/unloading for large worlds",
        "testStrategy": "",
        "status": "done",
        "dependencies": [],
        "priority": "high",
        "subtasks": [],
        "updatedAt": "2025-09-30T01:18:47.064Z"
      },
      {
        "id": 14,
        "title": "Create Substance 3D Designer PBR Material Authoring Documentation",
        "description": "Document the complete workflow for setting up Substance 3D Designer projects to create PBR materials compatible with the engine's deferred rendering pipeline, including export presets and integration guides.",
        "details": "This task involves creating comprehensive documentation for PBR material authoring workflow:\n\n1. **Substance 3D Designer Project Configuration**:\n   - Document project template setup with proper output size (2K, 4K) and bit depth (8/16-bit)\n   - Configure graph templates for PBR metallic-roughness workflow\n   - Set up proper color space management (sRGB for albedo/emissive, Linear for others)\n   - Document node naming conventions and organization best practices\n   - Create reusable function graphs for common material operations\n\n2. **PBR Output Map Configuration**:\n   - **Albedo/Base Color**: RGB channels, sRGB color space, no alpha or packed with opacity\n   - **Normal Map**: RGB channels, Linear space, OpenGL or DirectX format specification\n   - **Metallic-Roughness Combined**: Metallic in R channel, Roughness in G channel, Linear space\n   - **Emissive**: RGB channels, sRGB or HDR format for bloom effects\n   - **Ambient Occlusion**: Single channel or RGB, Linear space\n   - Document channel packing strategies for optimization\n\n3. **Export Preset Creation**:\n   - Create export presets for each texture type with proper naming conventions\n   - Configure output formats: PNG for development, DDS/KTX2 for production\n   - Set up batch export configurations for texture sets\n   - Document compression settings for each map type\n   - Create Python automation scripts for batch processing\n\n4. **Integration Workflow Documentation**:\n   - Step-by-step guide for exporting from Substance to engine assets folder\n   - Material JSON/XML descriptor format matching engine requirements\n   - Texture file naming conventions (e.g., material_name_albedo.png)\n   - Directory structure for organized material libraries\n   - Hot-reload integration for rapid iteration\n\n5. **Material Templates and Examples**:\n   - Create base material templates (metal, dielectric, translucent)\n   - Document parameter ranges for physically accurate materials\n   - Provide example graphs for common materials (concrete, metal, wood, fabric)\n   - Include height-to-normal conversion settings\n   - Document displacement and tessellation map generation\n\n6. **Optimization Guidelines**:\n   - Texture resolution guidelines based on object size and importance\n   - Channel packing strategies to reduce texture count\n   - Mipmap generation settings for different map types\n   - Performance considerations for texture streaming\n   - Memory budget recommendations\n\n7. **Validation and Testing Workflow**:\n   - Material validation checklist for PBR compliance\n   - Test scene setup in Substance 3D Viewer\n   - Engine material preview tool documentation\n   - Common issues and troubleshooting guide\n   - Performance profiling integration\n\n8. **Advanced Techniques**:\n   - Procedural material generation workflows\n   - Material layering and blending techniques\n   - Dynamic material property exposure for runtime modification\n   - Substance parameter integration with engine material system\n   - SBSAR runtime integration documentation",
        "testStrategy": "1. **Documentation Completeness Verification**:\n   - Verify all PBR texture types are documented with examples\n   - Ensure export presets cover all required formats\n   - Check that integration steps are reproducible\n   - Validate that material templates work correctly\n\n2. **Workflow Testing**:\n   - Follow documentation to create a test material from scratch\n   - Export using documented presets and verify output formats\n   - Import into engine and verify correct rendering\n   - Test channel packing and unpacking in shaders\n\n3. **Technical Accuracy**:\n   - Verify color space specifications are correct\n   - Ensure normal map handedness matches engine requirements\n   - Validate metallic-roughness packing in correct channels\n   - Test that emissive values produce expected bloom\n\n4. **Integration Testing**:\n   - Create sample materials following the guide\n   - Verify materials render correctly in deferred pipeline\n   - Test hot-reload functionality with exported textures\n   - Ensure material descriptors parse correctly\n\n5. **Performance Validation**:\n   - Measure texture memory usage with recommended settings\n   - Verify mipmap chains generate correctly\n   - Test texture streaming with various resolutions\n   - Profile material shader compilation times",
        "status": "pending",
        "dependencies": [
          "12"
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 15,
        "title": "Create Blender 3D Workflow Documentation for Game Asset Creation",
        "description": "Document comprehensive Blender 3D workflows for creating game assets compatible with the engine, covering modeling, UV unwrapping, PBR material setup, and export configurations for FBX/glTF formats.",
        "details": "This task involves creating detailed documentation for the complete Blender 3D asset creation pipeline:\n\n1. **Blender Project Setup and Configuration**:\n   - Document recommended Blender version (3.6 LTS or newer) and addon requirements\n   - Configure unit scale settings for consistent asset sizing (1 Blender Unit = 1 meter)\n   - Set up viewport shading modes for PBR preview (Material Preview with Studio lighting)\n   - Document collection hierarchy best practices for asset organization\n   - Configure color management settings (Filmic/AgX for proper HDR workflow)\n\n2. **3D Modeling Workflow Documentation**:\n   - Document polygon modeling best practices for game assets\n   - Topology guidelines for deformable vs static meshes\n   - LOD (Level of Detail) creation workflow with target polygon counts\n   - Hard surface modeling techniques with proper edge flow\n   - Organic modeling considerations for characters/creatures\n   - Modular asset creation for tileable/repeatable elements\n   - Multi-resolution workflow using subdivision modifiers\n   - Proper use of modifiers stack (Array, Mirror, Solidify, etc.)\n\n3. **UV Unwrapping and Texel Density**:\n   - UV unwrapping strategies for different asset types\n   - Maintaining consistent texel density across assets (e.g., 10.24 pixels/cm)\n   - UV island packing optimization with proper padding\n   - UDIM workflow for high-detail assets\n   - Texture atlas creation for multiple small objects\n   - Seam placement best practices to minimize visible artifacts\n   - UV channel management for lightmaps (UV2)\n\n4. **PBR Material Setup in Blender**:\n   - Principled BSDF node configuration for PBR workflow\n   - Texture map connections:\n     * Albedo/Base Color (sRGB color space)\n     * Normal Map (Non-Color, tangent space)\n     * Metallic Map (Non-Color, 0-1 range)\n     * Roughness Map (Non-Color, 0-1 range)\n     * Ambient Occlusion (Non-Color, multiply with albedo)\n     * Emissive Map (sRGB for color, HDR values supported)\n     * Height/Displacement (Non-Color, for parallax occlusion)\n   - Material ID setup for texture baking\n   - Shader complexity considerations for real-time rendering\n\n5. **Normal Map and Tangent Space Configuration**:\n   - High-poly to low-poly baking workflow\n   - Cage setup for clean normal map baking\n   - Tangent space vs object space normal maps\n   - Synced vs non-synced normal workflow (MikkTSpace standard)\n   - Hard edge/smoothing group setup for normal maps\n   - Normal map strength calibration\n   - Fixing common normal map artifacts (gradients, seams)\n\n6. **FBX Export Configuration**:\n   - FBX export settings for game engines:\n     * Scale: Apply Unit Scale\n     * Forward/Up axis configuration (Y Forward, Z Up typical)\n     * Apply Modifiers on export\n     * Triangulate faces for consistency\n     * Tangent space export options\n   - Animation export settings (if applicable)\n   - Batch export workflow for multiple assets\n   - FBX version compatibility notes\n\n7. **glTF 2.0 Export Configuration**:\n   - glTF export advantages over FBX\n   - Binary (.glb) vs separate files (.gltf)\n   - PBR material preservation in glTF\n   - Texture embedding vs external references\n   - Draco mesh compression settings\n   - KHR extensions support (transmission, clearcoat, etc.)\n   - Animation and skinning export\n\n8. **Asset Optimization Guidelines**:\n   - Polygon count targets by asset type:\n     * Props: 100-5,000 triangles\n     * Characters: 5,000-50,000 triangles\n     * Environments: modular approach with instancing\n   - Texture resolution guidelines (512x512 to 4096x4096)\n   - Draw call optimization through material consolidation\n   - Mesh optimization tools (Decimate modifier, Remesh)\n   - Texture channel packing (e.g., ORM - Occlusion, Roughness, Metallic)\n   - LOD generation workflow with reduction percentages\n\n9. **Integration with Engine Pipeline**:\n   - Asset naming conventions for auto-import\n   - Folder structure organization\n   - Metadata embedding for asset properties\n   - Collision mesh setup and naming\n   - Reference coordinate system alignment\n   - Scale factor verification\n   - Material slot naming for engine mapping\n\n10. **Quality Assurance Checklist**:\n    - Mesh validation (no n-gons, proper normals, no zero-area faces)\n    - UV validation (no overlapping, within 0-1 space)\n    - Texture format requirements (power of 2, compression ready)\n    - Performance profiling guidelines\n    - Common pitfall troubleshooting guide",
        "testStrategy": "1. **Documentation Validation**:\n   - Create sample assets following each documented workflow\n   - Verify all export settings produce engine-compatible files\n   - Test normal map baking with provided settings\n   - Validate PBR material setup matches engine rendering\n\n2. **Workflow Testing**:\n   - Follow documentation to create a complete game asset from scratch\n   - Test FBX export with various asset types (static mesh, skinned mesh)\n   - Verify glTF export maintains PBR properties\n   - Import test assets into engine to verify compatibility\n\n3. **Optimization Verification**:\n   - Measure polygon counts against documented targets\n   - Verify texture resolutions follow guidelines\n   - Test LOD chains for proper reduction\n   - Profile draw calls with consolidated materials\n\n4. **Cross-Reference Testing**:\n   - Ensure documentation aligns with engine's deferred rendering requirements (Task 12)\n   - Verify material setup matches Substance Designer workflow (Task 14)\n   - Test asset packaging with .lore tools (Task 3)\n   - Validate tilemap compatibility for modular assets (Task 13)\n\n5. **User Acceptance Testing**:\n   - Have team members create assets using only the documentation\n   - Gather feedback on unclear sections\n   - Verify all necessary Blender features are documented\n   - Ensure troubleshooting section covers common issues",
        "status": "pending",
        "dependencies": [
          "3",
          "12",
          "13"
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 16,
        "title": "Research and Implement Tiled Map Editor Integration",
        "description": "Establish integration with Tiled map editor for level design workflow. Basic JSON import is complete and functional. Advanced features like bi-directional control, JavaScript plugins, and live sync remain to be implemented.",
        "status": "pending",
        "dependencies": [
          "13"
        ],
        "priority": "high",
        "details": "Current implementation status and remaining work:\n\n**COMPLETED - Basic Import Functionality**:\n- TiledImporter class successfully loads and parses .tmj files\n- Reads custom tile properties (mesh_path, height, collision_type, etc.)\n- Integrates with TilemapWorldSystem for 3D world generation\n- Test room (11x11 tiles) loads and renders correctly\n- Basic tile-to-mesh mapping system operational\n\n**REMAINING - Advanced Integration Features**:\n\n1. **Enhanced Import Capabilities**:\n   - External tileset files (.tsx) support\n   - Multi-layer support (terrain, objects, collision layers)\n   - Object layers with custom properties for entity spawning\n   - Tile rotation and flipping flags handling\n   - Support for larger maps and infinite map format\n   - Chunk-based loading for streaming large worlds\n\n2. **Custom JavaScript Export Plugin**:\n   - Create Tiled plugin using tiled.registerMapFormat API\n   - Export directly to engine's optimized binary format\n   - Pre-process tile-to-mesh mappings for faster loading\n   - Validation of map data against engine requirements\n   - Automatic mesh instance batching hints\n   - Export statistics and warnings in Tiled UI\n\n3. **Bi-directional Integration (MCP Server)**:\n   - Implement MCP server for Tiled automation\n   - Control Tiled from engine (open maps, modify tiles)\n   - Programmatic map generation from engine\n   - Query and modify map data via API\n   - Synchronize changes between Tiled and engine\n\n4. **Live Development Workflow**:\n   - Hot-reload support for .tmj files during runtime\n   - File watcher for automatic reload on save\n   - Live sync between Tiled and running engine\n   - Debug visualization overlay for loaded tile data\n   - Performance profiling for map loading operations\n   - Validation tool for checking map constraints\n\n5. **Documentation and Tooling**:\n   - Complete integration guide for level designers\n   - Document all supported custom properties\n   - Create example Tiled project with standard tileset\n   - Troubleshooting guide for common issues\n   - Best practices for performance optimization",
        "testStrategy": "Testing approach divided by implementation status:\n\n**COMPLETED - Basic Import Tests**:\n- ✓ TiledImporter loads simple .tmj files\n- ✓ Custom properties are parsed correctly\n- ✓ Integration with TilemapWorldSystem works\n- ✓ 11x11 test room renders properly\n\n**REMAINING - Enhanced Feature Tests**:\n\n1. **Extended Import Tests**:\n   - Test external tileset (.tsx) loading and resolution\n   - Verify multi-layer maps (terrain, walls, objects)\n   - Validate tile rotation and flipping transformations\n   - Test large maps (1000x1000) and infinite maps\n   - Verify chunk-based streaming for performance\n\n2. **JavaScript Plugin Tests**:\n   - Compare JSON vs custom format export (size, speed)\n   - Test plugin error handling for invalid configurations\n   - Verify optimized binary format loads faster\n   - Validate batching hints improve rendering\n\n3. **Bi-directional Integration Tests**:\n   - Test MCP server connection and commands\n   - Verify programmatic map generation\n   - Test round-trip: Engine → Tiled → Engine\n   - Validate synchronized editing workflow\n\n4. **Live Workflow Tests**:\n   - Modify .tmj while engine running, verify hot-reload\n   - Test file watcher responds to all change types\n   - Measure reload performance impact\n   - Verify debug overlay shows correct tile info\n\n5. **Performance Benchmarks**:\n   - Load time comparison: JSON vs binary format\n   - Memory usage for various map sizes\n   - Streaming performance with chunked maps\n   - Mesh instancing efficiency measurements",
        "subtasks": [
          {
            "id": 1,
            "title": "Enhance TiledImporter for production features",
            "description": "Extend existing TiledImporter to support external tilesets, multi-layer maps, object layers, rotations, and large/infinite maps",
            "status": "pending",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Develop custom JavaScript export plugin for Tiled",
            "description": "Create Tiled plugin for optimized binary export format with validation and batching hints",
            "status": "pending",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Implement MCP server for bi-directional integration",
            "description": "Build MCP server to control Tiled from engine and enable programmatic map generation",
            "status": "pending",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Add hot-reload and live sync capabilities",
            "description": "Implement file watching, hot-reload, and live synchronization between Tiled and engine",
            "status": "pending",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Create documentation and example projects",
            "description": "Write comprehensive guides, document properties, and provide example Tiled projects",
            "status": "pending",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 17,
        "title": "Create Test Room in Tiled Editor for 3D Mesh Verification",
        "description": "Design and create a simple 11x11 test room using Tiled map editor with walls, floor, door, and props, then export as TMJ format with custom properties for 3D mesh mapping to verify FBX mesh loading functionality.",
        "details": "This task involves creating a test map using the Tiled map editor to verify the 3D tilemap system's mesh loading capabilities:\n\n1. **Install and Configure Tiled Editor**:\n   - Download and install Tiled map editor (version 1.10.0 or newer)\n   - Configure default map settings for game compatibility\n   - Set up custom properties template for tile definitions\n\n2. **Create Map Structure**:\n   - Create new map with dimensions 11x11 tiles\n   - Set tile size to match engine requirements (e.g., 32x32 or 64x64 pixels)\n   - Configure map orientation as orthogonal\n   - Set rendering order to right-down\n\n3. **Design Room Layout**:\n   - Create border walls using wall tiles (positions 0,0 to 10,0, 0,0 to 0,10, etc.)\n   - Fill interior with floor tiles (1,1 to 9,9)\n   - Place door tile at position (5,0) or (5,10) for entrance\n   - Add prop tiles:\n     - Table at position (3,3)\n     - Chair at positions (2,3) and (4,3)\n     - Chest/container at position (8,8)\n     - Lamp/light source at position (5,5)\n     - Bookshelf along wall at (1,5)\n\n4. **Configure Tile Custom Properties**:\n   - For each tile type, add the following custom properties:\n     - `mesh_path` (string): Path to FBX mesh file (e.g., \"assets/meshes/wall.fbx\")\n     - `height` (float): Height of the tile in world units (e.g., 3.0 for walls, 0.1 for floor)\n     - `blocks_sight` (bool): Whether tile blocks line of sight (true for walls, false for floor)\n     - `transparency` (float): Opacity value 0.0-1.0 (1.0 for solid, 0.5 for windows)\n     - `collision_type` (string): \"solid\", \"passable\", or \"trigger\"\n     - `material_type` (string): \"stone\", \"wood\", \"metal\" for physics interactions\n\n5. **Set Up Tile Layers**:\n   - Create \"floor\" layer for ground tiles\n   - Create \"walls\" layer for wall and door tiles\n   - Create \"props\" layer for furniture and objects\n   - Create \"metadata\" layer for spawn points and triggers\n   - Configure layer opacity and visibility settings\n\n6. **Add Spawn and Interaction Points**:\n   - Place player spawn point object at position (5,9)\n   - Add interaction triggers near props (for future testing)\n   - Mark special tiles with additional properties:\n     - Door: `interactive=true`, `locked=false`\n     - Chest: `interactive=true`, `container=true`\n\n7. **Export Configuration**:\n   - Configure export settings for JSON format\n   - Enable tile property embedding\n   - Set coordinate system to match engine (Y-up or Z-up)\n   - Include tileset references as embedded or external\n\n8. **Export and File Placement**:\n   - Export map as \"test_room.tmj\" (Tiled JSON format)\n   - Place exported file in \"assets/maps/\" directory\n   - Copy any referenced tileset images to \"assets/maps/tilesets/\"\n   - Ensure all custom property paths are relative to project root\n\n9. **Create Accompanying Documentation**:\n   - Document tile ID to mesh mapping\n   - List all custom properties and their purposes\n   - Include screenshot of designed room layout\n   - Note any special considerations for mesh loading\n\n10. **Prepare Test Assets**:\n    - Ensure referenced FBX files exist in specified paths\n    - Create placeholder meshes if needed:\n      - wall.fbx (simple cube scaled to tile size)\n      - floor.fbx (flat plane)\n      - door.fbx (door frame with opening)\n      - table.fbx, chair.fbx, chest.fbx (basic prop meshes)",
        "testStrategy": "1. **File Structure Verification**:\n   - Verify test_room.tmj exists in assets/maps/ directory\n   - Check that file is valid JSON and parseable\n   - Ensure all tile layers are present and properly structured\n   - Validate coordinate data matches expected 11x11 grid\n\n2. **Tile Property Validation**:\n   - Parse TMJ file and verify each tile has required custom properties\n   - Check that mesh_path values point to valid file locations\n   - Ensure height values are appropriate for tile types (walls > floors)\n   - Verify blocks_sight is true for walls, false for floors and most props\n   - Confirm transparency values are within 0.0-1.0 range\n\n3. **Map Layout Testing**:\n   - Verify walls form complete border (no gaps)\n   - Ensure door tile is properly placed and accessible\n   - Check that props don't overlap inappropriately\n   - Validate spawn point is in walkable area\n\n4. **Engine Integration Testing**:\n   - Load TMJ file in engine's tilemap loader\n   - Verify each tile correctly references its FBX mesh\n   - Check that meshes load at correct positions based on tile coordinates\n   - Ensure custom properties are accessible in code\n   - Test that height values affect mesh placement correctly\n\n5. **Visual Verification**:\n   - Render the loaded room in 3D\n   - Verify walls appear at correct height\n   - Check that floor tiles create continuous surface\n   - Ensure props are placed at expected positions\n   - Validate door appears as opening in wall\n\n6. **Property Functionality Testing**:\n   - Test that blocks_sight property affects visibility calculations\n   - Verify transparency affects rendering (if implemented)\n   - Check collision detection uses collision_type property\n   - Test material_type affects physics interactions\n\n7. **Performance Validation**:\n   - Measure load time for TMJ file parsing\n   - Check memory usage for loaded tile data\n   - Verify mesh instancing works for repeated tiles\n   - Test that unnecessary meshes aren't loaded multiple times",
        "status": "done",
        "dependencies": [
          "13"
        ],
        "priority": "high",
        "subtasks": [],
        "updatedAt": "2025-09-30T17:41:20.550Z"
      },
      {
        "id": 18,
        "title": "Wire up TilemapWorldSystem to main game loop",
        "description": "Integrate the TilemapWorldSystem into main.cpp, initialize the world system with test room data from TiledImporter, handle update cycles, and add camera controls for 3D world navigation.",
        "status": "done",
        "dependencies": [
          "11",
          "12",
          "13"
        ],
        "priority": "high",
        "details": "Implementation steps for TilemapWorldSystem integration:\n\n1. **Main.cpp Integration** (COMPLETED):\n   - ✓ Included TilemapWorldSystem headers\n   - ✓ Created TilemapWorldSystem instance after ECS World initialization\n   - ✓ Passed Vulkan context and ECS World reference to constructor\n   - ✓ Registered TilemapWorldSystem with ECS as a system\n\n2. **TiledImporter Setup** (COMPLETED):\n   - ✓ Implemented TiledImporter class to load Tiled (.tmx) map files\n   - ✓ Parse tile layer data, object layers, and custom properties\n   - ✓ Convert Tiled format to internal tilemap representation\n   - ✓ Created test room map file (11x11 test room)\n   - ✓ Map tile GIDs to FBX mesh references in tile properties\n\n3. **Fix Build Dependencies** (CRITICAL - NEW):\n   - Fix missing vk_mem_alloc.h header dependency\n   - Fix missing lore/core/types.hpp header\n   - Ensure all Vulkan memory allocation headers are properly included\n   - Verify core type definitions are available\n\n4. **World Initialization**:\n   - ✓ Load test room map using TiledImporter on startup (11x11 room loads successfully)\n   - Generate ECS entities for each tile (walls, floors, props)\n   - Assign Transform, MeshRenderer, and Collider components to tile entities\n   - Set up mesh instancing for identical tiles (walls, floors)\n   - Initialize spatial partitioning for efficient culling\n\n5. **Game Loop Integration**:\n   - Add TilemapWorldSystem::update() to main game loop\n   - Handle chunk loading/unloading based on camera position\n   - Update tile entity transforms and visibility\n   - Process tile interactions and state changes\n   - Synchronize with rendering system for draw calls\n\n6. **Camera System Implementation**:\n   - Create FreeFlyCameraController component\n   - Implement WASD movement with Shift/Space for vertical movement\n   - Mouse look for rotation (pitch/yaw)\n   - Scroll wheel for FOV adjustment\n   - Camera frustum culling integration\n   - Smooth camera interpolation for fluid movement\n\n7. **Rendering Integration**:\n   - Connect TilemapWorldSystem with deferred renderer\n   - Load FBX meshes referenced in tile properties\n   - Submit tile mesh instances to G-Buffer geometry pass\n   - Implement LOD system for distant tiles\n   - Add debug visualization for tile boundaries and chunks\n\n8. **Memory Management**:\n   - Implement chunk pooling to avoid allocation overhead\n   - Use arena allocators for tile entity components\n   - Profile and optimize mesh instance buffer updates",
        "testStrategy": "1. **Integration Tests**:\n   - ✓ TilemapWorldSystem initializes without crashes\n   - ✓ Test room map (11x11) loads correctly from Tiled file\n   - ✓ FBX mesh references are properly parsed from tile properties\n   - Verify build compiles after fixing header dependencies\n   - Check that all tiles generate corresponding ECS entities\n   - Validate mesh instances are created for tile types\n\n2. **Build Fix Tests**:\n   - Verify vk_mem_alloc.h is properly included and linked\n   - Confirm lore/core/types.hpp exists and contains required type definitions\n   - Test clean build passes all compilation stages\n   - Ensure no undefined symbol errors during linking\n\n3. **Rendering Tests**:\n   - Ensure all tiles render with correct FBX meshes and materials\n   - Verify instancing reduces draw calls for identical tiles\n   - Test frustum culling removes off-screen tiles\n   - Check LOD system switches mesh quality at distance thresholds\n\n4. **Camera Tests**:\n   - Test WASD movement in all directions\n   - Verify mouse look controls pitch/yaw correctly\n   - Ensure camera doesn't clip through solid tiles\n   - Test smooth interpolation between positions\n\n5. **Performance Tests**:\n   - Profile frame time with loaded 11x11 test room\n   - Measure chunk loading/unloading time\n   - Monitor memory usage during world exploration\n   - Verify 60+ FPS once graphics errors are resolved\n\n6. **Update Loop Tests**:\n   - Confirm world updates every frame\n   - Test tile state changes propagate correctly\n   - Verify spatial queries return correct tile entities",
        "subtasks": [],
        "updatedAt": "2025-09-30T20:22:57.460Z"
      },
      {
        "id": 19,
        "title": "Implement Debug Visualization Rendering for Vision Systems",
        "description": "Create a comprehensive debug visualization renderer that consumes VisionDebugData to display line-of-sight rays, field-of-view cones, vision range circles, and labeled debug information using Vulkan primitive rendering with color-coded results and keyboard-toggled overlay support.",
        "details": "Implementation approach for vision system debug visualization:\n\n1. **Debug Data Structures**:\n   - Define VisionDebugData struct with arrays for debug primitives\n   - Line data: start/end positions, colors for LOS rays\n   - Box data: min/max bounds, colors for bounding volumes\n   - Circle data: center, radius, segments for vision ranges\n   - Label data: position, text, color for debug annotations\n   - FOV cone data: origin, direction, angle, range\n\n2. **Vulkan Debug Renderer Component**:\n   - Create DebugRenderer class inheriting from base renderer\n   - Vertex buffer for dynamic line/box geometry\n   - Uniform buffer for view/projection matrices\n   - Push constants for per-primitive colors\n   - Separate pipeline for line topology (VK_PRIMITIVE_TOPOLOGY_LINE_LIST)\n   - Pipeline for line strips (VK_PRIMITIVE_TOPOLOGY_LINE_STRIP)\n   - Alpha blending for transparent overlays\n\n3. **Primitive Generation**:\n   - Line renderer: Direct vertex pairs for LOS rays\n   - Box renderer: 12 lines from 8 vertices (wireframe)\n   - Circle renderer: Generate N segments based on radius\n   - FOV cone: Generate cone outline with arc segments\n   - Frustum visualization for 3D vision volumes\n\n4. **Color Coding System**:\n   - Green: Clear line of sight\n   - Red: Blocked/occluded vision\n   - Yellow: Partial occlusion\n   - Blue: FOV boundaries\n   - Cyan: Vision range limits\n   - White: Debug labels and annotations\n   - Alpha channel for overlay transparency\n\n5. **Vertex Buffer Management**:\n   - Dynamic vertex buffer with staging\n   - Per-frame buffer updates for animated debug data\n   - Vertex format: position (vec3) + color (vec4)\n   - Index buffer for optimized primitive rendering\n   - Double buffering for smooth updates\n\n6. **Shader Implementation**:\n   - Vertex shader: MVP transformation, pass-through color\n   - Fragment shader: Simple color output with alpha\n   - Line width via geometry shader or render pass settings\n   - Screen-space text rendering for labels\n\n7. **Integration with Vision System**:\n   - Subscribe to vision system debug events\n   - Collect debug data each frame\n   - Convert world-space vision data to render primitives\n   - Batch similar primitives for efficiency\n\n8. **Keyboard Toggle System**:\n   - F1: Toggle entire debug overlay\n   - F2: Toggle LOS rays only\n   - F3: Toggle FOV cones only\n   - F4: Toggle vision ranges\n   - F5: Toggle debug labels\n   - F6: Cycle through color schemes\n   - Persistent debug state across frames\n\n9. **Performance Optimization**:\n   - Frustum culling for off-screen debug primitives\n   - Level-of-detail for distant debug geometry\n   - Instanced rendering for repeated primitives\n   - Conditional rendering based on debug flags\n\n10. **Debug Information Display**:\n    - Vision cone angle in degrees\n    - Range distance in world units\n    - Occlusion percentage for partial blocks\n    - Entity vision state (alert, searching, idle)\n    - Performance metrics (ray count, occlusion tests)",
        "testStrategy": "Comprehensive testing approach for debug visualization:\n\n1. **Primitive Rendering Tests**:\n   - Verify line rendering between two points\n   - Test box wireframe generation from bounds\n   - Validate circle approximation with various segment counts\n   - Ensure FOV cone geometry matches angle parameters\n   - Check frustum visualization accuracy\n\n2. **Color Coding Validation**:\n   - Spawn entity with clear LOS to target (expect green)\n   - Place obstacle between entity and target (expect red)\n   - Test partial occlusion scenarios (expect yellow)\n   - Verify FOV boundary colors (expect blue)\n   - Check vision range limit visualization (expect cyan)\n\n3. **Dynamic Update Tests**:\n   - Move entity and verify debug rays follow\n   - Rotate entity and check FOV cone updates\n   - Add/remove obstacles and verify color changes\n   - Test rapid updates without flicker or lag\n\n4. **Keyboard Toggle Tests**:\n   - Press F1 and verify overlay appears/disappears\n   - Test individual component toggles (F2-F5)\n   - Verify state persistence across toggle cycles\n   - Check that game rendering continues normally\n\n5. **Performance Benchmarks**:\n   - Render 1000 debug lines without frame drops\n   - Test with 50 entities with full debug visualization\n   - Measure GPU memory usage for debug buffers\n   - Profile vertex buffer update times\n\n6. **Integration Tests**:\n   - Verify debug data matches actual vision calculations\n   - Test with multiple vision systems active\n   - Ensure debug overlay layers correctly over game\n   - Validate coordinate space transformations\n\n7. **Edge Case Testing**:\n   - Zero-length lines (same start/end point)\n   - Degenerate boxes (zero volume)\n   - Extreme FOV angles (0°, 180°, 360°)\n   - Vision range at world boundaries\n   - Label rendering at screen edges",
        "status": "pending",
        "dependencies": [
          "12",
          "10"
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 20,
        "title": "Implement Vision and Visibility System with Shadow Casting FOV",
        "description": "Add VisionComponent and VisibilityComponent to the ECS framework, implement VisionSystem with shadow casting field-of-view algorithm, and create vision-based AI behaviors for entities to react to visible targets.",
        "status": "done",
        "dependencies": [],
        "priority": "high",
        "details": "This task implements a comprehensive vision and visibility system for the game engine:\n\n1. **Create Vision Components** (COMPLETED):\n   - VisionComponent: Stores vision parameters (range, FOV angle, vision type) - IMPLEMENTED\n   - VisibilityComponent: Stores calculated visible tiles and entities - IMPLEMENTED\n   - Component registration pending ECS integration (no Registry class in current architecture)\n   - Implement component serialization for save/load functionality\n\n2. **Adapt VisionSystem to Existing ECS Architecture**:\n   - VisionSystem core implementation complete with clean API\n   - Adapt system to work without Registry class (current ECS uses different architecture)\n   - Integrate with existing ECS component management patterns\n   - Process entities with VisionComponent each frame\n   - Calculate visible tiles using shadow casting from entity position\n   - Store results in VisibilityComponent's visible tile set\n\n3. **Align Environmental Conditions Integration**:\n   - EnvironmentalConditions struct exists in vision_profile.hpp with different fields\n   - Map existing environmental fields to vision modifiers\n   - Adapt vision range and clarity based on actual environmental struct\n   - Support different vision modes using existing structures\n\n4. **Shadow Casting FOV Algorithm Implementation**:\n   - Implement recursive shadow casting algorithm for accurate FOV calculation\n   - Support configurable vision range (tiles) and FOV angle (degrees)\n   - Handle octant-based shadow propagation for efficient computation\n   - Account for tile opacity values (transparent, opaque, partial)\n   - Optimize with spatial hashing for large-scale maps\n\n5. **Vision-Based AI Behaviors**:\n   - Implement AIVisionBehavior component for reactive AI\n   - Create detection system: entities detect visible threats/targets\n   - Implement pursuit behavior when target is visible\n   - Add hiding/fleeing when predator is spotted\n   - Create investigation behavior for lost targets\n   - Support faction-based target prioritization\n\n6. **Player Vision Configuration**:\n   - Default player vision: 15 tile range, 360° FOV\n   - Support vision modifiers (darkness reduces range)\n   - Implement directional vision option (cone-based FOV)\n   - Add vision enhancement items/abilities\n   - Create debug visualization for FOV boundaries\n\n7. **Performance Optimizations**:\n   - Cache FOV calculations when entity hasn't moved\n   - Use dirty flag system to trigger recalculation\n   - Implement LOD system: reduce FOV accuracy for distant NPCs\n   - Batch vision calculations for grouped entities\n   - Consider GPU compute shader acceleration for massive entity counts\n\n8. **Integration Points**:\n   - Hook into movement system to trigger FOV updates\n   - Connect with rendering system for fog-of-war display\n   - Interface with AI decision trees for behavior selection\n   - Support save/load of visibility state",
        "testStrategy": "1. **Component Integration Tests**:\n   - Verify VisionComponent and VisibilityComponent work with existing ECS (no Registry)\n   - Test component creation and destruction in current architecture\n   - Validate component data serialization and deserialization\n   - Check component query performance with 1000+ entities\n\n2. **Environmental Conditions Mapping Tests**:\n   - Test vision_profile.hpp EnvironmentalConditions integration\n   - Verify field mapping produces expected vision modifications\n   - Validate vision adjustments based on environmental factors\n   - Test edge cases with extreme environmental values\n\n3. **Shadow Casting Algorithm Tests**:\n   - Create test map with known visibility patterns\n   - Verify correct FOV calculation for all 8 octants\n   - Test edge cases: corners, diagonal walls, partial opacity\n   - Validate vision range limits are enforced\n   - Compare results against reference implementation\n\n4. **VisionSystem Performance Tests**:\n   - Benchmark with 100, 500, 1000 entities with vision\n   - Verify 60 FPS maintained with typical entity counts\n   - Test cache effectiveness (90%+ hit rate when stationary)\n   - Profile memory usage with large visible tile sets\n\n5. **AI Behavior Tests**:\n   - Spawn AI entity and player, verify detection occurs\n   - Test line-of-sight breaking stops pursuit\n   - Validate investigation behavior at last known position\n   - Check faction-based targeting priorities\n   - Test multiple AI entities don't interfere with each other\n\n6. **Integration Tests**:\n   - Move entity, verify FOV updates correctly\n   - Test fog-of-war rendering matches visibility data\n   - Verify AI decisions change based on visibility\n   - Load/save game, check visibility state preserved\n\n7. **Player Experience Tests**:\n   - Verify player FOV feels responsive and accurate\n   - Test vision modifiers apply correctly\n   - Check debug visualization renders properly\n   - Validate no visual artifacts or flickering",
        "subtasks": [
          {
            "id": 1,
            "title": "Adapt VisionSystem to existing ECS architecture",
            "description": "Modify VisionSystem to work without Registry class and integrate with current ECS patterns",
            "status": "done",
            "dependencies": [],
            "details": "<info added on 2025-09-30T07:10:15.325Z>\nInvestigation started into adapting VisionSystem to the actual ECS architecture. Found critical architectural mismatch: VisionSystem implementation assumes a Registry-based ECS pattern that doesn't exist in the current codebase. The actual architecture uses a World class with ComponentArrays for component storage and management. Located TransformComponent definition in input_ecs.hpp which will be needed for position queries.\n\nRequired architectural changes identified:\n1. Replace all Registry references with World class usage\n2. Refactor view() pattern calls to directly iterate over ComponentArrays using World's component access methods\n3. Adapt all get() component accessor calls to match World's API conventions\n4. Update include directives and forward declarations to reference actual ECS headers instead of non-existent Registry headers\n\nThis adaptation is blocking progress on mapping EnvironmentalConditions to vision modifiers since the base system needs to compile and integrate with the existing ECS first.\n</info added on 2025-09-30T07:10:15.325Z>",
            "testStrategy": "",
            "updatedAt": "2025-09-30T07:11:51.540Z",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Map EnvironmentalConditions fields to vision modifiers",
            "description": "Align vision_profile.hpp EnvironmentalConditions struct fields with vision system expectations",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": "",
            "parentId": "undefined",
            "updatedAt": "2025-09-30T07:12:14.075Z"
          },
          {
            "id": 3,
            "title": "Complete ECS component registration",
            "description": "Register VisionComponent and VisibilityComponent using existing ECS registration patterns",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": "",
            "parentId": "undefined",
            "updatedAt": "2025-09-30T07:14:25.524Z"
          },
          {
            "id": 4,
            "title": "Implement shadow casting FOV algorithm",
            "description": "Create recursive shadow casting with octant propagation and tile opacity support",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": "",
            "parentId": "undefined",
            "updatedAt": "2025-09-30T07:14:41.689Z"
          },
          {
            "id": 5,
            "title": "Create AI vision behaviors",
            "description": "Implement detection, pursuit, fleeing, and investigation behaviors based on visibility",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": "",
            "parentId": "undefined",
            "updatedAt": "2025-09-30T07:17:52.921Z"
          }
        ],
        "updatedAt": "2025-09-30T07:17:52.921Z"
      },
      {
        "id": 21,
        "title": "Verify FBX Mesh Loading Integration with Tile Rendering",
        "description": "Validate that the 3D tilemap system correctly loads and renders FBX meshes from tile definitions, ensuring proper transformation of rotation, tinting, and material properties in the deferred rendering pipeline.",
        "details": "This task focuses on verifying the complete integration between FBX mesh loading and tile rendering systems:\n\n1. **FBX Mesh Loading Verification**:\n   - Confirm FbxImporter correctly loads mesh geometry, normals, and UV coordinates\n   - Verify material properties extraction from FBX files (diffuse, metallic, roughness)\n   - Test mesh_path property resolution in tile definitions JSON\n   - Validate mesh caching system prevents redundant loads\n   - Ensure proper error handling for missing or corrupt FBX files\n\n2. **Tile-to-Mesh Mapping Testing**:\n   - Create test tile definitions with mesh_path pointing to FBX files\n   - Verify TileRenderer correctly instantiates meshes at tile positions\n   - Test multi-tile objects (2x2, 3x3) with single FBX mesh\n   - Confirm tile layer ordering affects mesh rendering depth\n   - Validate fallback to default mesh when mesh_path is invalid\n\n3. **Transformation Pipeline Validation**:\n   - Test rotation property (0°, 90°, 180°, 270°) applied to mesh transforms\n   - Verify tinting color multiplies with material albedo correctly\n   - Confirm scale factors from tile definitions apply to mesh instances\n   - Test transform concatenation: tile position + rotation + scale\n   - Validate world-space transformation matrices in vertex shaders\n\n4. **Material Properties Integration**:\n   - Verify PBR material parameters from FBX propagate to G-Buffer\n   - Test metallic/roughness values render correctly in deferred pipeline\n   - Confirm texture coordinates map properly from FBX UVs\n   - Validate normal mapping if present in FBX materials\n   - Test material instancing for repeated tiles\n\n5. **Test Room Setup**:\n   - Create small 10x10 tile test room with walls, floor, and objects\n   - Use simple cube.fbx for walls, plane.fbx for floor\n   - Add rotated wall sections to test transformation\n   - Include tinted tiles (red walls, blue floor) for color testing\n   - Place debug camera to view entire room\n\n6. **Performance Profiling**:\n   - Measure mesh loading times for various FBX complexities\n   - Profile GPU memory usage with instanced vs unique meshes\n   - Test draw call batching for tiles sharing same mesh\n   - Validate frustum culling works with mesh bounding boxes\n   - Benchmark with 1000+ tile instances",
        "testStrategy": "1. **FBX Loading Tests**:\n   - Create test FBX files: cube.fbx, plane.fbx, pyramid.fbx with materials\n   - Load each mesh and verify vertex/index buffer creation\n   - Check material properties match FBX source values\n   - Test loading non-existent mesh_path gracefully fails\n   - Verify mesh cache returns same instance for duplicate paths\n\n2. **Tile Rendering Tests**:\n   - Create tilemap JSON with mesh_path for each tile type\n   - Render single tile and verify mesh appears at correct position\n   - Test 2x2 door tile spans multiple grid cells correctly\n   - Verify z-fighting doesn't occur between adjacent tiles\n   - Confirm tile removal cleans up mesh instances\n\n3. **Transformation Tests**:\n   - Place wall tile at (5,5) with 90° rotation, verify orientation\n   - Apply red tint to floor tiles, confirm color in framebuffer\n   - Scale tile to 2x size, verify mesh bounds update\n   - Test negative scale for mesh mirroring\n   - Validate transform matrix multiplication order\n\n4. **Material Tests**:\n   - Create metallic cube (metallic=1.0) and rough cube (roughness=1.0)\n   - Verify G-Buffer metallicRoughness attachment contains correct values\n   - Test textured FBX displays texture correctly\n   - Confirm emission materials glow in lighting pass\n   - Validate transparent materials handle alpha correctly\n\n5. **Integration Tests**:\n   - Build complete test room with 100 tiles of various types\n   - Verify no rendering artifacts or z-fighting\n   - Test camera movement through room without culling issues\n   - Profile frame time stays under 16ms (60 FPS)\n   - Confirm all tiles visible in final composed image\n\n6. **Debug Tools**:\n   - Implement debug overlay showing mesh names at tile positions\n   - Add wireframe mode to visualize mesh geometry\n   - Create heat map of draw calls per tile\n   - Log mesh loading failures with tile coordinates\n   - Provide runtime mesh reload command for testing",
        "status": "pending",
        "dependencies": [
          "12",
          "13"
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 22,
        "title": "Create Custom Tiled JavaScript Export Plugin",
        "description": "Implement a custom Tiled editor JavaScript plugin using tiled.registerMapFormat API to export optimized map format with enhanced custom properties support, providing greater control over map data structure and integration with the engine.",
        "details": "This task involves creating a custom Tiled JavaScript export plugin for enhanced control over map data:\n\n1. **Plugin Development Environment Setup**:\n   - Set up JavaScript development environment for Tiled plugins\n   - Install Tiled API documentation and TypeScript definitions if available\n   - Create plugin directory structure in Tiled extensions folder\n   - Configure plugin metadata file (plugin.json) with name, version, and description\n\n2. **Implement Custom Map Format Exporter**:\n   ```javascript\n   // lore-export.js\n   var customMapFormat = {\n       name: \"Lore Engine Map Format\",\n       extension: \"lmap\",\n       \n       write: function(map, fileName) {\n           // Custom export logic\n           var exportData = {\n               version: \"1.0.0\",\n               engine: \"lore\",\n               metadata: {\n                   created: new Date().toISOString(),\n                   tiledVersion: tiled.version,\n                   mapName: map.fileName\n               },\n               dimensions: {\n                   width: map.width,\n                   height: map.height,\n                   tileWidth: map.tileWidth,\n                   tileHeight: map.tileHeight,\n                   depth: map.property(\"depth\") || 1\n               },\n               layers: [],\n               tilesets: [],\n               objects: [],\n               customProperties: {}\n           };\n           \n           // Process layers with optimized data structure\n           for (var i = 0; i < map.layerCount; ++i) {\n               var layer = map.layerAt(i);\n               exportData.layers.push(processLayer(layer));\n           }\n           \n           // Process tilesets with mesh mapping\n           map.tilesets.forEach(function(tileset) {\n               exportData.tilesets.push(processTileset(tileset));\n           });\n           \n           // Export as optimized binary or JSON\n           var file = new TextFile(fileName, TextFile.WriteOnly);\n           file.write(JSON.stringify(exportData, null, 2));\n           file.commit();\n       }\n   };\n   \n   tiled.registerMapFormat(\"lore-map\", customMapFormat);\n   ```\n\n3. **Custom Property Processing**:\n   - Extract tile-level custom properties (meshPath, material, collision)\n   - Process object layer properties for entities and triggers\n   - Handle layer-specific rendering properties (renderOrder, opacity)\n   - Support nested property structures for complex data\n   - Implement property validation and type checking\n\n4. **Optimization Features**:\n   - Implement RLE compression for tile data\n   - Group identical tiles to reduce redundancy\n   - Generate tile usage statistics and indices\n   - Create spatial indexing for large maps\n   - Support chunk-based export for streaming\n\n5. **Mesh and Material Mapping**:\n   ```javascript\n   function processTileset(tileset) {\n       var processedTileset = {\n           name: tileset.name,\n           firstGid: tileset.firstGid,\n           tileCount: tileset.tileCount,\n           tileWidth: tileset.tileWidth,\n           tileHeight: tileset.tileHeight,\n           meshMappings: {},\n           materialMappings: {}\n       };\n       \n       // Process each tile's custom properties\n       for (var i = 0; i < tileset.tileCount; ++i) {\n           var tile = tileset.tile(i);\n           if (tile.property(\"meshPath\")) {\n               processedTileset.meshMappings[i] = {\n                   path: tile.property(\"meshPath\"),\n                   scale: tile.property(\"meshScale\") || [1, 1, 1],\n                   rotation: tile.property(\"meshRotation\") || [0, 0, 0]\n               };\n           }\n           if (tile.property(\"material\")) {\n               processedTileset.materialMappings[i] = {\n                   name: tile.property(\"material\"),\n                   parameters: JSON.parse(tile.property(\"materialParams\") || \"{}\")\n               };\n           }\n       }\n       \n       return processedTileset;\n   }\n   ```\n\n6. **Enhanced Data Structures**:\n   - Implement hierarchical layer groups support\n   - Add prefab instance references for repeated structures\n   - Support LOD (Level of Detail) information per tile\n   - Include navigation mesh generation hints\n   - Export light probe placement data\n\n7. **Plugin Configuration Interface**:\n   - Create configuration dialog for export options\n   - Add compression level settings\n   - Include format version selection\n   - Provide property filtering options\n   - Support profile presets for different use cases\n\n8. **Error Handling and Validation**:\n   - Validate map structure before export\n   - Check for missing mesh references\n   - Verify property types and ranges\n   - Provide detailed error messages\n   - Log export statistics and warnings\n\n9. **Installation and Distribution**:\n   - Create installation script for plugin deployment\n   - Package plugin with dependencies\n   - Document installation steps for different OS\n   - Provide uninstall/update procedures\n   - Include example maps and configurations\n\n10. **Documentation Creation**:\n    - Write comprehensive plugin usage guide\n    - Document all custom property formats\n    - Create property schema documentation\n    - Provide integration examples with engine\n    - Include troubleshooting section",
        "testStrategy": "1. **Plugin Installation Verification**:\n   - Verify plugin appears in Tiled's export formats menu\n   - Check that plugin loads without errors in console\n   - Confirm all plugin files are in correct directories\n   - Test plugin enable/disable functionality\n\n2. **Export Functionality Testing**:\n   - Create test map with all supported features\n   - Export using custom format and verify output file\n   - Compare exported data structure with expected format\n   - Validate JSON/binary output is well-formed\n\n3. **Custom Property Handling**:\n   - Test mesh path property export and validation\n   - Verify material properties are correctly mapped\n   - Check nested property structures export properly\n   - Validate property type conversion accuracy\n\n4. **Optimization Verification**:\n   - Compare file sizes between standard and optimized export\n   - Verify RLE compression produces correct tile data\n   - Test chunk-based export for large maps\n   - Measure export performance with different map sizes\n\n5. **Integration Testing**:\n   - Import exported maps into engine successfully\n   - Verify mesh mappings load correct 3D models\n   - Test material assignments render properly\n   - Confirm all custom properties are accessible in engine\n\n6. **Error Handling Tests**:\n   - Test export with missing mesh references\n   - Verify proper handling of invalid property values\n   - Check error messages are clear and actionable\n   - Test recovery from partial export failures\n\n7. **Cross-Platform Testing**:\n   - Test plugin on Windows Tiled installation\n   - Verify functionality on macOS and Linux\n   - Check file path handling across platforms\n   - Test with different Tiled versions\n\n8. **Documentation Validation**:\n   - Follow installation guide on fresh system\n   - Verify all code examples work as documented\n   - Test example maps export successfully\n   - Validate property schema with real maps",
        "status": "pending",
        "dependencies": [
          "17",
          "10"
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 23,
        "title": "Implement TileMeshCache with GPU Instancing",
        "description": "Create efficient mesh resource management system with reference counting and GPU instancing for intact tiles",
        "details": "Create TileMeshCache class with std::unordered_map<MeshID, shared_ptr<MeshData>>. Implement reference counting using atomic integers. Set up GPU instancing with instance buffers for transforms (model matrices). Use glDrawElementsInstanced or equivalent for rendering. Create instance data structure: struct TileInstanceData { glm::mat4 transform; uint32_t tileState; uint32_t materialID; }. Implement automatic unloading when ref count reaches zero. Target memory usage: 64 bytes per intact tile. Ensure single mesh is shared by thousands of tiles.",
        "testStrategy": "Unit tests for reference counting logic. Performance benchmarks measuring draw calls (target: 2 per room). Memory profiling to verify 64 bytes per tile. Stress test with 10,000+ tiles sharing same mesh. Visual verification of instanced rendering.",
        "priority": "high",
        "dependencies": [],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 24,
        "title": "Core Voronoi Fracture System Implementation",
        "description": "Develop 3D Voronoi fracture algorithm to generate 15-30 irregular debris pieces from broken tiles",
        "details": "Implement Poisson disk sampling for uniform fracture point distribution (minimum distance between points). Integrate voro++ library or implement Fortune's algorithm for 3D Voronoi computation. Create DebrisPiece struct: struct DebrisPiece { std::vector<glm::vec3> vertices; std::vector<uint32_t> indices; std::vector<glm::vec3> normals; std::vector<glm::vec2> uvs; uint32_t materialID; }. Implement Sutherland-Hodgman algorithm for clipping Voronoi cells against original mesh boundaries. Calculate UV coordinates for new vertices using barycentric interpolation. Generate per-fragment normals using face normals and smoothing. Target: 15-30 pieces per fracture, <20ms generation time.",
        "testStrategy": "Unit tests for Poisson disk sampling distribution. Validate Voronoi cells are convex and non-overlapping. Performance tests ensuring <20ms fracture time. Visual tests comparing fragments to original mesh. Verify UV mapping continuity across fragments.",
        "priority": "high",
        "dependencies": [
          23
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 25,
        "title": "Physics Properties and Debris Simulation",
        "description": "Calculate physics properties for debris pieces and implement realistic tumbling and collision",
        "details": "For each debris piece, calculate: centroid using volume-weighted average, mass from volume and material density, inertia tensor using parallel axis theorem. Create physics state: struct DebrisPhysics { glm::vec3 position, velocity, angularVelocity; glm::quat rotation; float mass; glm::mat3 inertiaTensor; bool sleeping; }. Implement Euler integration for position/rotation updates. Add angular damping (0.98 per frame) for realistic tumbling. Implement simple AABB collision detection between pieces. Add sleeping threshold: velocity < 0.01 m/s and angular velocity < 0.1 rad/s. Use spatial hashing for broad-phase collision detection.",
        "testStrategy": "Unit tests for centroid and inertia calculations. Physics simulation tests with known outcomes. Verify conservation of momentum in collisions. Performance tests with 100+ debris pieces. Visual validation of realistic tumbling motion.",
        "priority": "high",
        "dependencies": [
          24
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 26,
        "title": "Directional and Impact-Aware Fracture System",
        "description": "Implement stress-guided fracture patterns based on impact type and material properties",
        "details": "Create ImpactData struct: struct ImpactData { glm::vec3 position, direction; float force; enum Type { PointImpact, BluntForce, Explosion, Cutting, Crushing, Shearing } type; float duration; }. Implement stress-guided Voronoi point generation: higher density near impact (use exponential falloff), radial bias for explosions, linear bias for cutting. Material-specific patterns: Stone (5-8 pieces, angular, large variation), Wood (15-25 pieces, elongated along grain direction), Glass (20-40 pieces, sharp triangular, radial from impact). Fragment size gradient using weighted Voronoi (smaller cells near impact). Add +2ms overhead target for directional processing.",
        "testStrategy": "Visual tests for each impact type and material. Verify fragment count matches material specs. Test fragment size gradient distribution. Performance tests ensuring <2ms overhead. Validate stress propagation patterns.",
        "priority": "medium",
        "dependencies": [
          24
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 27,
        "title": "Progressive Damage and Crack System",
        "description": "Build health-based damage states with visible crack propagation and warning signs",
        "details": "Create TileDamage struct: struct TileDamage { float health; enum State { Pristine, Scratched, Cracked, Damaged, Failing, Critical, Collapsed } state; std::vector<CrackPath> cracks; float damageAccumulation; }. Implement crack propagation: CrackPath with start/end points and width, propagate at 0.1-1.0 m/s along stress lines using A* pathfinding, width increases under stress (max 5cm). Render cracks as decal textures on intact mesh using projective texturing. State transitions at health thresholds: 100%, 80%, 60%, 40%, 20%, 10%, 0%. Visual feedback: dust particles, slight shaking at Critical state. Update loop targets 0.1ms per crack per frame.",
        "testStrategy": "Unit tests for state transitions. Visual tests for crack rendering. Performance tests with 10+ active cracks. Verify crack propagation speed and direction. Test warning sign visibility and timing.",
        "priority": "medium",
        "dependencies": [
          23
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 28,
        "title": "Two-Floor Demo Scene with Structural Integrity",
        "description": "Create test environment demonstrating progressive collapse and pillar dependencies",
        "details": "Design in Tiled: Ground floor 15x15 tiles with 4 load-bearing pillars at (5,5), (5,10), (10,5), (10,10). Upper floor 15x15 with 5x5 alcove extending over ground floor. Define tile types: FloorTile (0.1m height), WallTile (1.0m cube), PillarTile (1.0m, structural: true, loadCapacity: 1000kg), CeilingTile (0.1m, hanging). Implement basic structural integrity: dependency graph using adjacency list, BFS traversal to find supported tiles, weight calculation propagating downward, overload detection (weight > capacity triggers collapse). Progressive collapse: 2-5 tiles per frame, 2-3 second total collapse time. Add visual indicators: stress coloring on overloaded tiles.",
        "testStrategy": "Test each scenario: bullet (small cone), hammer (radial cracks), explosive (full collapse). Verify pillar destruction triggers alcove collapse. Measure collapse timing (2-3 seconds). Test load propagation calculations. Visual validation of dramatic collapse sequence.",
        "priority": "high",
        "dependencies": [
          25,
          27
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 29,
        "title": "Fluid Simulation Integration with Voxel Approximation",
        "description": "Add internal voxel grid for fluid/debris interaction without rendering voxels",
        "details": "Create internal 4x4x4 voxel grid per debris piece: struct VoxelGrid { bool occupied[64]; glm::vec3 cellSize; glm::mat4 localToWorld; }. Never render voxels - only for physics. Calculate buoyancy: submerged volume using voxel occupancy, upward force = fluid_density * submerged_volume * gravity. Add drag force: F_drag = -0.5 * drag_coefficient * velocity.length() * velocity.normalized(). Update voxel positions as debris rotates using transform matrix. Interface with existing fluid system through collision callbacks. Memory budget: 1KB per debris piece for voxel data.",
        "testStrategy": "Unit tests for buoyancy calculations. Verify voxels are never rendered. Test fluid force calculations. Visual tests of debris floating/sinking. Performance impact <0.5ms for 50 pieces in fluid.",
        "priority": "low",
        "dependencies": [
          25
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 30,
        "title": "Pre-Fracture Tool and Offline Generation Pipeline",
        "description": "Build offline tool to pre-compute fracture patterns for instant loading at runtime",
        "details": "Create standalone tool 'lore-fracture-tool': command-line interface accepting mesh files (FBX, OBJ, glTF), generate 5+ fracture variants using different Voronoi seeds. Output .fracture file format: header with version and mesh hash, fragment count and variant count, per-fragment: vertex/index/normal/UV data, connectivity graph for structural analysis. Implement runtime loader: fast deserialization (<1ms target), fallback to runtime Voronoi if file missing, cache loaded fractures in memory. Add variation selection: random or based on impact parameters. File size target: ~250KB per mesh (5 variants × 50KB).",
        "testStrategy": "Compare pre-fractured vs runtime quality. Benchmark load times (<1ms target). Test fallback mechanism. Validate file format compatibility. Memory usage tests with 50+ cached fractures.",
        "priority": "low",
        "dependencies": [
          24
        ],
        "status": "pending",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-09-30T20:24:14.530Z",
      "updated": "2025-09-30T20:30:49.741Z",
      "description": "Tasks for master context"
    }
  },
  "graphics": {
    "tasks": [
      {
        "id": 1,
        "title": "Fix Vulkan semaphore validation errors in graphics system",
        "description": "Resolve Vulkan validation layer errors by implementing proper per-frame semaphore management and synchronization primitives according to modern GPU best practices.",
        "details": "The current implementation in src/graphics/graphics.cpp shows problematic semaphore management patterns that can lead to validation errors:\n\n1. **Critical Issue**: Lines 596-599 create semaphores per swapchain image but line 681 uses `current_frame % image_available_semaphores.size()` which can cause semaphore reuse before GPU completion\n2. **Semaphore Pool Problem**: Lines 705 and 714 reuse semaphores incorrectly - render_finished_semaphores are indexed by imageIndex but may be in use by previous frames\n3. **Missing Timeline Semaphores**: The code uses binary semaphores which require complex tracking. Implement VK_KHR_timeline_semaphore for simpler synchronization\n\nImplementation steps:\n1. Replace per-swapchain-image semaphores with proper per-frame-in-flight semaphores (2 sets for MAX_FRAMES_IN_FLIGHT)\n2. Create frame synchronization structure:\n   ```cpp\n   struct FrameSyncObjects {\n       VkSemaphore imageAvailable;\n       VkSemaphore renderFinished;  \n       VkFence inFlightFence;\n   };\n   std::vector<FrameSyncObjects> frameSync;\n   ```\n3. Update draw_frame() to use frame-based indexing consistently:\n   - Line 681: Use frameSync[current_frame].imageAvailable\n   - Line 705: Use frameSync[current_frame].imageAvailable for wait\n   - Line 714: Use frameSync[current_frame].renderFinished for signal\n4. Implement proper cleanup in recreate_swapchain() - don't destroy/recreate semaphores\n5. Add VK_KHR_timeline_semaphore support if available (check device extensions)\n6. Implement frame pacing with timeline semaphores for smoother rendering\n7. Add validation layer callbacks to catch synchronization issues early\n8. Use vkGetSemaphoreCounterValue for debugging timeline semaphore values",
        "testStrategy": "1. Enable Vulkan validation layers with synchronization validation: VK_LAYER_KHRONOS_validation\n2. Set environment variable VK_LAYER_ENABLES=VK_VALIDATION_FEATURE_ENABLE_SYNCHRONIZATION_VALIDATION_EXT\n3. Run application and verify no validation errors appear in console output\n4. Test window resize extensively - recreate_swapchain() should not produce validation errors\n5. Use RenderDoc or Nsight Graphics to capture frame and verify semaphore timeline\n6. Stress test with rapid window resizing and minimizing/restoring\n7. Profile with Tracy or similar to ensure no GPU stalls from incorrect synchronization\n8. Verify MAX_FRAMES_IN_FLIGHT works correctly (change to 3 and test)\n9. Check that vkDeviceWaitIdle() in shutdown() completes without hanging",
        "status": "done",
        "dependencies": [],
        "priority": "high",
        "subtasks": [],
        "updatedAt": "2025-09-28T18:06:16.873Z"
      },
      {
        "id": 2,
        "title": "Implement complete Audio System for Lore engine based on AEON's sophisticated acoustics",
        "description": "Create a comprehensive spatial audio system with miniaudio integration, including 3D positional audio, directional sound sources, environmental acoustics with reverb and occlusion, material-based sound propagation, Doppler effects, and full ECS integration for entity-driven audio processing. Foundation work completed with AcousticsSystem initialization, resource management, and shader compilation.",
        "status": "in-progress",
        "dependencies": [],
        "priority": "medium",
        "details": "The Lore engine has established a solid audio system foundation in src/audio/audio.cpp with miniaudio integration and core AudioSystem/AcousticsSystem classes. **COMPLETED**: AcousticsSystem initialization/shutdown with proper resource management, acoustic ray pool, material database, spatial hierarchy, and GLSL to SPIR-V shader compilation system. This task now focuses on implementing the advanced features with full GPU acceleration:\n\n**1. ENHANCE MINIAUDIO INTEGRATION (src/audio/audio.cpp:100-126)**\n- Complete audio device enumeration and selection\n- Implement proper audio format negotiation (currently hardcoded to F32)\n- Add support for multiple audio devices and routing\n- Implement audio stream management with proper buffering\n- Add audio file decoding using miniaudio decoders (MP3, OGG, WAV, FLAC)\n- Replace placeholder sine wave generation (lines 206-208) with actual audio data playback\n\n**2. DIRECTIONAL SOUND SOURCE MANAGEMENT** [Priority Focus]\n- Create DirectionalAudioSourceComponent with cone parameters:\n  - Inner/outer cone angles for directivity patterns\n  - Cone orientation vectors (forward direction)\n  - Volume falloff outside cone\n- Implement HRTF (Head-Related Transfer Function) processing beyond simple panning (lines 338-341)\n- Add binaural audio processing for realistic 3D positioning\n- Support for multiple directivity patterns (cardioid, omnidirectional, shotgun)\n\n**3. ENVIRONMENTAL ACOUSTICS WITH GPU COMPUTE** [Priority Focus]\n- Extend ReverbComponent (include/lore/audio/audio.hpp:205-231) with GPU-accelerated convolution\n- Implement impulse response convolution using GPU compute shaders:\n  - Create gpu_audio_convolution.comp shader for FFT-based convolution (leverage working shader compilation)\n  - Use VulkanGpuComputeSystem for parallel audio processing\n- Complete acoustic ray tracing implementation (audio.cpp:600-604) using established ray pool:\n  - Cast rays from sound sources through the environment\n  - Calculate reflections based on AcousticMaterial properties from material database\n  - Build reflection paths for early reflections and late reverb\n- Implement sound occlusion with GPU ray marching:\n  - Test line-of-sight between source and listener\n  - Apply frequency-dependent filtering for occluded sounds\n  - Calculate diffraction around obstacles\n\n**4. MATERIAL-BASED SOUND INTERACTION** (Building on material database)\n- Extend AcousticMaterial struct (audio.hpp:85-105) with frequency-dependent properties:\n  - Absorption coefficients per frequency band (125Hz-8kHz)\n  - Reflection characteristics (specular vs diffuse)\n  - Transmission loss curves\n- Enhance MaterialAudioDatabase with common materials:\n  - Concrete, wood, glass, metal, fabric, water, air\n  - Temperature and humidity effects on propagation\n- Implement surface interaction calculations:\n  - Reflection angle and energy based on material impedance\n  - Scattering based on surface roughness\n  - Transmission through materials with filtering\n\n**5. ADVANCED DOPPLER EFFECTS AND PHYSICS**\n- Enhance Doppler calculation (audio.cpp:751-764) with:\n  - Relativistic Doppler for high-speed objects\n  - Sonic boom generation for supersonic sources\n  - Atmospheric effects (temperature gradients, wind)\n- Add acoustic physics simulation:\n  - Speed of sound variation with temperature/pressure\n  - Atmospheric absorption at high frequencies\n  - Ground effect for low-flying sound sources\n- Implement psychoacoustic effects:\n  - Loudness curves (Fletcher-Munson)\n  - Masking effects between frequencies\n  - Precedence effect for echo suppression\n\n**6. GPU-ACCELERATED ECS INTEGRATION** (Leverage spatial hierarchy)\n- Create GPU compute shader for audio source updates (gpu_audio_update.comp):\n  - Process all AudioSourceComponents in parallel on GPU\n  - Calculate 3D positioning and attenuation on GPU\n  - Stream results back for CPU mixing\n- Implement audio LOD system using spatial hierarchy:\n  - Cull inaudible sources based on distance/occlusion\n  - Reduce update frequency for distant sounds\n  - Simplify processing for sounds below hearing threshold\n- Add audio component pooling for performance:\n  - Pre-allocate audio buffers in GPU memory\n  - Use ring buffers for streaming audio\n  - Implement zero-copy audio paths where possible\n\n**7. PERFORMANCE OPTIMIZATION**\n- Enhance spatial audio culling with octree/BVH (building on spatial hierarchy):\n  - Organize sound sources spatially\n  - Quick rejection of sources outside hearing range\n  - Hierarchical LOD based on listener distance\n- Add SIMD optimization for audio mixing (use AVX2/AVX-512):\n  - Vectorized sample mixing\n  - SIMD-accelerated FFT for frequency analysis\n  - Parallel filter processing\n- Create audio thread pool for parallel processing:\n  - Dedicate threads for audio callback\n  - Worker threads for effect processing\n  - Lock-free audio queues\n\n**8. COMPLETE MISSING IMPLEMENTATIONS**\n- Replace all placeholder/simplified code:\n  - FFT implementation (audio.cpp:689-699) - integrate real FFT library\n  - Audio file loading (audio.cpp:515-526) - use miniaudio decoders\n  - Convolution reverb (audio.cpp:388-416) - implement proper convolution\n- Add missing utility functions:\n  - Spectral analysis tools\n  - Audio effect chains (compression, EQ, distortion)\n  - Procedural audio generation (wind, water, machinery)\n\n**INTEGRATION WITH EXISTING SYSTEMS:**\n- Leverage VulkanGpuComputeSystem (src/graphics/gpu_compute.cpp) for parallel processing\n- Use existing ECS infrastructure (src/ecs/ecs.cpp) for component management\n- Integrate with Transform components from math system for positioning\n- Coordinate with physics system for velocity/acceleration data\n- Utilize working GLSL to SPIR-V compilation for audio compute shaders\n\n**CODE STRUCTURE:**\n- Main implementation: src/audio/audio.cpp (enhance existing)\n- Headers: include/lore/audio/audio.hpp (extend interfaces)\n- GPU shaders: shaders/compute/gpu_audio_*.comp (new, use existing compilation pipeline)\n- Tests: src/audio/tests/audio_tests.cpp (comprehensive testing)",
        "testStrategy": "1. **Unit Tests for Core Audio Components**:\n   - Test miniaudio device initialization and audio callback\n   - Verify audio file loading for all supported formats\n   - Test 3D positioning calculations and HRTF processing\n   - Validate Doppler shift calculations at various velocities\n   - Test material property calculations and acoustic impedance\n   - **NEW**: Verify AcousticsSystem resource management and cleanup\n   - **NEW**: Test acoustic ray pool allocation and deallocation\n   - **NEW**: Validate material database lookups and properties\n\n2. **Integration Tests with ECS**:\n   - Create entities with AudioSourceComponent and verify playback\n   - Test listener switching between multiple AudioListenerComponents\n   - Verify component updates trigger audio parameter changes\n   - Test entity destruction properly cleans up audio resources\n   - **NEW**: Test spatial hierarchy updates with moving entities\n\n3. **GPU Compute Performance Tests**:\n   - Benchmark GPU audio convolution vs CPU implementation\n   - Test parallel processing of 1000+ audio sources\n   - Verify GPU buffer synchronization and data coherency\n   - Profile memory usage and identify leaks with VMA tracking\n   - **NEW**: Test shader compilation pipeline for audio compute shaders\n   - **NEW**: Verify SPIR-V generation from GLSL audio shaders\n\n4. **Acoustic Simulation Tests**:\n   - Create test scene with known acoustic properties\n   - Verify reverb matches expected RT60 times\n   - Test occlusion with obstacles between source and listener\n   - Validate ray tracing produces correct reflection paths using ray pool\n   - Test frequency-dependent absorption matches real materials from database\n\n5. **Real-time Performance Tests**:\n   - Ensure audio callback never underruns at 44.1kHz/48kHz\n   - Verify < 10ms latency from trigger to playback\n   - Test CPU usage stays below 10% with 100 active sources\n   - Validate no audio artifacts or pops during stress tests\n\n6. **Doppler and Physics Tests**:\n   - Test approaching/receding sources produce correct pitch shift\n   - Verify supersonic sources generate sonic boom effects\n   - Test atmospheric effects on sound propagation\n   - Validate psychoacoustic models with listening tests\n\n7. **Memory and Resource Tests**:\n   - Test loading/unloading of large audio files\n   - Verify proper cleanup on shutdown (no Vulkan validation errors)\n   - Test audio buffer pool allocation and recycling\n   - Validate no memory leaks over extended runtime\n   - **NEW**: Test AcousticsSystem resource pool management under stress",
        "subtasks": [
          {
            "id": 1,
            "title": "AcousticsSystem Foundation Infrastructure",
            "description": "Implement core AcousticsSystem initialization, shutdown, and resource management",
            "status": "done",
            "dependencies": [],
            "details": "Completed implementation of AcousticsSystem initialization and shutdown with proper resource management including acoustic ray pool for efficient ray processing, material database for acoustic property lookups, and spatial hierarchy for organizing audio sources. Also completed graphics shader compilation system with GLSL to SPIR-V compilation using glslangValidator.",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 3,
        "title": "Create Configuration System with INI parsing, hot-reload, and per-system settings",
        "description": "Implement a comprehensive configuration management system with INI file parsing, automatic hot-reloading of changes, hierarchical per-system settings, and GPU-accelerated configuration distribution to compute shaders.",
        "details": "The Lore engine requires a robust configuration system similar to AEON's comprehensive config management. This implementation must support hierarchical configuration files, runtime hot-reloading, and efficient GPU buffer updates for shader-accessible settings:\n\n**1. CORE CONFIGURATION ARCHITECTURE**\n- Create src/config/config.h and config.cpp with ConfigurationSystem class\n- Implement hierarchical config structure: global -> system -> subsystem settings\n- Design ConfigNode class for type-safe value storage with variant<int, float, string, bool, vec3, vec4>\n- Add ConfigWatcher using platform-specific file monitoring (ReadDirectoryChangesW on Windows, inotify on Linux)\n- Implement thread-safe config access with read-write locks for hot-reload safety\n\n**2. INI PARSER IMPLEMENTATION**\n- Create src/config/ini_parser.cpp with robust INI parsing supporting:\n  - Sections [Graphics], [Audio], [Physics], [Input]\n  - Multi-line values with continuation character \\\n  - Comments with ; and # prefixes\n  - Variable interpolation ${section.key} syntax\n  - Array values: key = value1, value2, value3\n  - Include directives: @include \"other_config.ini\"\n- Handle UTF-8 encoding and cross-platform line endings\n- Implement error reporting with line numbers and context\n\n**3. HOT-RELOAD SYSTEM**\n- Implement FileWatcher class using platform APIs:\n  - Windows: ReadDirectoryChangesW with IOCP for async monitoring\n  - Linux: inotify_add_watch with epoll for efficient polling\n- Create ConfigReloadManager with debouncing (100ms delay) to handle rapid changes\n- Implement differential reload - only update changed values\n- Add validation pass before applying changes to prevent invalid configs\n- Trigger callbacks for systems that need to respond to config changes\n\n**4. PER-SYSTEM SETTINGS MANAGEMENT**\n- Create system-specific config classes:\n  - GraphicsConfig: resolution, vsync, MSAA, HDR settings, GPU device selection\n  - AudioConfig: device, sample rate, channels, buffer size, 3D audio settings\n  - PhysicsConfig: gravity, timestep, solver iterations, collision layers\n  - InputConfig: key bindings, mouse sensitivity, deadzone, vibration\n- Implement config inheritance: system configs can override global defaults\n- Add config profiles for different scenarios (performance, quality, debug)\n\n**5. GPU CONFIGURATION BUFFER SYSTEM**\n- Create uniform buffer for shader-accessible configuration:\n  ```cpp\n  struct GPUConfigData {\n      float4 graphics_settings;  // resolution.xy, aspect_ratio, time\n      float4 physics_params;     // gravity.xyz, timestep\n      float4 audio_params;       // master_volume, sfx_volume, music_volume, doppler_factor\n      float4x4 debug_flags;      // 16 debug toggles as matrix\n  };\n  ```\n- Implement automatic GPU buffer updates when config changes\n- Use push constants for frequently changing values\n- Create descriptor set specifically for configuration data\n\n**6. CONFIGURATION API**\n```cpp\nclass ConfigurationSystem {\npublic:\n    // Core access methods\n    template<typename T> T get(const std::string& path, T default_value);\n    template<typename T> void set(const std::string& path, T value);\n    bool exists(const std::string& path) const;\n    \n    // Batch operations\n    void load_ini(const std::string& filepath);\n    void save_ini(const std::string& filepath);\n    void merge_config(const ConfigNode& other);\n    \n    // Hot-reload management\n    void enable_hot_reload(const std::string& directory);\n    void register_change_callback(const std::string& path, std::function<void()> callback);\n    \n    // GPU synchronization\n    void update_gpu_buffer(VkCommandBuffer cmd);\n    VkDescriptorSet get_config_descriptor() const;\n};\n```\n\n**7. DEFAULT CONFIGURATION FILES**\n- Create config/default.ini with all default settings\n- Create config/graphics.ini for graphics-specific settings\n- Create config/keybindings.ini for input mappings\n- Implement config/debug.ini for development settings\n- Add .gitignore entries for user-specific configs\n\n**8. INTEGRATION WITH EXISTING SYSTEMS**\n- Update GraphicsSystem to read from config for resolution, vsync, etc.\n- Modify AudioSystem to use config for device selection and volume\n- Integrate with future PhysicsSystem for simulation parameters\n- Add config UI panel for runtime editing (using ImGui or equivalent)\n\n**9. PERFORMANCE OPTIMIZATIONS**\n- Use string interning for config keys to reduce memory and comparison costs\n- Implement lazy parsing - only parse sections when accessed\n- Cache frequently accessed values in local variables\n- Use memory-mapped files for large config files\n- Batch GPU buffer updates to minimize synchronization",
        "testStrategy": "1. **Unit Tests for INI Parser**:\n   - Test parsing of all INI syntax features (sections, comments, arrays, includes)\n   - Verify error handling for malformed INI files with proper line number reporting\n   - Test UTF-8 support and cross-platform line ending handling\n   - Validate variable interpolation and circular reference detection\n   - Test include directive with nested includes and cycle detection\n\n2. **Configuration Access Tests**:\n   - Test get/set operations for all supported types (int, float, string, bool, vec3, vec4)\n   - Verify hierarchical path resolution (graphics.resolution.width)\n   - Test default value fallback when keys don't exist\n   - Validate thread-safe concurrent access with multiple readers/writers\n   - Test configuration merging and override behavior\n\n3. **Hot-Reload Testing**:\n   - Create test config file and modify it while application runs\n   - Verify FileWatcher detects changes within 100ms\n   - Test debouncing with rapid successive file changes\n   - Validate that only changed values trigger callbacks\n   - Test atomic reload - partial changes don't apply if validation fails\n   - Verify no data races during hot-reload with stress test\n\n4. **GPU Buffer Synchronization**:\n   - Create test shader that reads configuration uniform buffer\n   - Modify config values and verify shader receives updates\n   - Test push constant updates for high-frequency changes\n   - Validate descriptor set binding and layout\n   - Measure update latency from config change to GPU visibility\n\n5. **System Integration Tests**:\n   - Test GraphicsSystem reading resolution and vsync from config\n   - Verify AudioSystem uses configured device and volume settings\n   - Test config profile switching (performance -> quality)\n   - Validate all systems receive hot-reload notifications\n   - Test fallback to defaults when config files are missing\n\n6. **Performance Benchmarks**:\n   - Measure config access time for 10,000 sequential reads\n   - Test concurrent access performance with 100 threads\n   - Benchmark hot-reload response time for 1MB config file\n   - Measure memory usage with various config sizes\n   - Profile GPU buffer update overhead\n\n7. **Error Handling Tests**:\n   - Test behavior with missing config files\n   - Verify handling of permission denied errors\n   - Test recovery from corrupted INI files\n   - Validate circular include detection\n   - Test out-of-memory conditions for large configs\n\n8. **Platform-Specific Tests**:\n   - Test FileWatcher on Windows with ReadDirectoryChangesW\n   - Verify Linux inotify implementation\n   - Test file locking behavior during hot-reload\n   - Validate cross-platform path handling",
        "status": "pending",
        "dependencies": [],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 4,
        "title": "Implement Physics Extensions based on AEON's realistic simulation",
        "description": "Create a comprehensive physics simulation system with thermodynamics, electromagnetics, acoustics integration, material physics, and environmental interactions, all accelerated through GPU compute shaders for realistic world simulation.",
        "details": "The Lore engine requires advanced physics extensions beyond basic rigid body dynamics, implementing realistic simulation systems that integrate with existing components. This implementation leverages GPU compute for all physics calculations:\n\n**1. THERMODYNAMICS SYSTEM (src/physics/thermodynamics.h/.cpp)**\n- Create ThermodynamicsSystem class with GPU compute pipeline for heat transfer\n- Implement temperature field simulation using 3D heat diffusion equation on GPU\n- Design ThermalComponent with properties: temperature, thermal_conductivity, specific_heat, emissivity\n- Create compute shaders for:\n  - Heat conduction between adjacent materials (Fourier's law)\n  - Convection simulation for fluids and gases\n  - Radiation heat transfer using Stefan-Boltzmann law\n  - Phase transitions (melting, boiling, freezing)\n- Integrate with material system for thermal property lookup\n- GPU buffer layout: packed thermal field data for coalesced memory access\n\n**2. ELECTROMAGNETICS SYSTEM (src/physics/electromagnetics.h/.cpp)**\n- Implement ElectromagneticsSystem with Maxwell's equations solver on GPU\n- Create ElectricComponent and MagneticComponent for entities\n- Design compute shaders for:\n  - Electric field calculation using Coulomb's law\n  - Magnetic field simulation with Biot-Savart law\n  - Electromagnetic wave propagation\n  - Induction and eddy current simulation\n  - Lorentz force calculations for charged particles\n- Implement GPU-accelerated FDTD (Finite-Difference Time-Domain) solver\n- Create electromagnetic material properties: permittivity, permeability, conductivity\n\n**3. ACOUSTICS PHYSICS INTEGRATION (src/physics/acoustics_physics.h/.cpp)**\n- Bridge physics system with existing audio system from Task 2\n- Implement wave equation solver for sound propagation on GPU\n- Create AcousticMaterialComponent with absorption, reflection, transmission coefficients\n- Design compute shaders for:\n  - Sound wave propagation through different media\n  - Acoustic impedance calculations at material boundaries\n  - Resonance and standing wave simulation\n  - Sound absorption and damping based on material properties\n- Integrate with spatial audio system for physically-based sound\n\n**4. MATERIAL PHYSICS SYSTEM (src/physics/material_physics.h/.cpp)**\n- Create unified MaterialPhysicsComponent combining all physical properties\n- Implement material property database with GPU-accessible lookup tables\n- Design stress-strain simulation for elastic/plastic deformation\n- Create compute shaders for:\n  - Young's modulus and Poisson's ratio calculations\n  - Fracture mechanics and material failure\n  - Fatigue and creep simulation\n  - Composite material behavior\n- Implement material state transitions (solid/liquid/gas/plasma)\n\n**5. ENVIRONMENTAL INTERACTIONS (src/physics/environment.h/.cpp)**\n- Create EnvironmentSystem for atmospheric and weather simulation\n- Implement fluid dynamics solver using Lattice Boltzmann Method on GPU\n- Design compute shaders for:\n  - Wind and air resistance calculations\n  - Pressure and density fields\n  - Humidity and precipitation simulation\n  - Atmospheric scattering for realistic lighting\n  - Buoyancy and drag forces\n- Integrate with particle systems for environmental effects\n\n**6. GPU COMPUTE INFRASTRUCTURE**\n- Extend existing GPUComputeSystem from src/graphics/gpu_compute.cpp\n- Create PhysicsComputePipeline with dedicated compute queues\n- Design unified physics buffer layout:\n  ```cpp\n  struct PhysicsData {\n      float4 position_mass;\n      float4 velocity_charge;\n      float4 force_temperature;\n      float4 material_properties;\n  };\n  ```\n- Implement GPU arena allocator for physics data (leverage existing implementation)\n- Create synchronization between physics and rendering pipelines\n\n**7. INTEGRATION WITH EXISTING SYSTEMS**\n- Integrate with TransformComponent for position updates\n- Connect to existing GPUParticleSystem for particle physics\n- Link with configuration system (Task 3) for runtime physics parameters\n- Ensure proper synchronization with audio system (Task 2) for acoustics\n\n**8. SHADER IMPLEMENTATION**\n- Create shaders/physics/ directory with compute shaders:\n  - thermal_diffusion.comp\n  - electromagnetic_field.comp\n  - wave_propagation.comp\n  - fluid_dynamics.comp\n  - material_deformation.comp\n- Implement shared physics constants buffer for all shaders\n- Design efficient workgroup sizes for different physics simulations",
        "testStrategy": "1. **Unit Tests for Physics Components**:\n   - Test thermal diffusion with known analytical solutions\n   - Verify electromagnetic field calculations against textbook examples\n   - Validate wave equation solver with simple harmonic motion\n   - Test material stress-strain curves against reference data\n   - Verify fluid dynamics with lid-driven cavity benchmark\n\n2. **GPU Compute Performance Tests**:\n   - Benchmark thermal simulation with 1M+ temperature points\n   - Test electromagnetic solver with complex field configurations\n   - Measure wave propagation performance with multiple sources\n   - Profile GPU memory usage and bandwidth utilization\n   - Verify compute shader correctness with CPU reference implementation\n\n3. **Integration Tests**:\n   - Test thermodynamics affecting material state transitions\n   - Verify electromagnetic forces on charged particles\n   - Validate acoustic propagation through different materials\n   - Test environmental effects on entity movement\n   - Ensure proper synchronization between all physics systems\n\n4. **Validation Tests**:\n   - Energy conservation in closed thermodynamic systems\n   - Maxwell's equations divergence conditions\n   - Wave equation boundary conditions\n   - Material property continuity at interfaces\n   - Numerical stability over long simulations\n\n5. **Interactive Tests**:\n   - Create physics sandbox with real-time parameter adjustment\n   - Test extreme conditions (very high/low temperatures, strong fields)\n   - Verify visual feedback matches physics calculations\n   - Test configuration hot-reload for physics parameters\n   - Validate performance with varying entity counts",
        "status": "pending",
        "dependencies": [
          "2",
          "3"
        ],
        "priority": "medium",
        "subtasks": []
      }
    ],
    "metadata": {
      "version": "1.0.0",
      "lastModified": "2025-09-29T07:10:20.683Z",
      "taskCount": 4,
      "completedCount": 1,
      "tags": [
        "graphics"
      ],
      "created": "2025-09-29T07:12:34.327Z",
      "description": "Tasks for graphics context",
      "updated": "2025-09-29T07:12:34.327Z"
    }
  },
  "assets": {
    "tasks": [
      {
        "id": 1,
        "title": "Implement comprehensive image loading system with stb_image integration for texture management and Vulkan GPU upload",
        "description": "Create a complete image asset loading system that integrates stb_image for loading various image formats and provides seamless Vulkan texture creation with GPU memory management, mipmapping, and format conversion capabilities.",
        "details": "Implementation requires several key components:\n\n1. **Image Asset Loader Class** (src/assets/image_loader.hpp/cpp):\n   - Inherit from AssetLoader base class\n   - Support formats: PNG, JPEG, TGA, BMP, PSD, GIF, HDR, PIC\n   - Handle loading with stb_image integration\n   - Convert loaded data to Vulkan-compatible formats\n   - Generate metadata including dimensions, channels, bit depth\n\n2. **Vulkan Texture Manager** (src/graphics/texture_manager.hpp/cpp):\n   - Create VkImage objects from loaded image data\n   - Manage VkImageView creation for shader access\n   - Handle VkSampler creation with filtering options\n   - Implement staging buffer for optimal GPU upload\n   - Support format conversion (RGBA8, RGB8, R8, etc.)\n   - Automatic mipmap generation using vkCmdBlitImage\n   - Manage texture memory with VkDeviceMemory allocation\n\n3. **Image Asset Component** (include/lore/assets/image_asset.hpp):\n   ```cpp\n   struct ImageAsset {\n       uint32_t width, height, channels;\n       VkFormat format;\n       VkImage image;\n       VkImageView image_view;\n       VkDeviceMemory memory;\n       VkSampler sampler;\n       uint32_t mip_levels;\n       bool is_srgb;\n   };\n   ```\n\n4. **Integration with Asset System**:\n   - Register ImageAssetLoader with AssetManager for AssetType::Texture\n   - Implement hot-reload support for texture updates\n   - Add texture streaming for large images\n   - Memory budget management for GPU textures\n\n5. **Vulkan Implementation Details**:\n   - Use VK_IMAGE_TILING_OPTIMAL for GPU performance\n   - Implement transition barriers: VK_IMAGE_LAYOUT_UNDEFINED -> VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL -> VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL\n   - Create command buffer helpers in graphics.cpp for texture operations\n   - Use existing buffer creation methods for staging\n   - Support both 2D textures and cubemaps\n\n6. **stb_image Integration**:\n   - Add stb_image to dependencies via CPM in CMakeLists.txt\n   - Create stb_image_impl.cpp with STB_IMAGE_IMPLEMENTATION\n   - Handle both 8-bit and HDR image loading\n   - Implement flip_vertically option for OpenGL compatibility\n\n7. **Memory Management**:\n   - Pool VkDeviceMemory allocations for small textures\n   - Implement texture atlas support for UI elements\n   - Add reference counting for shared textures\n   - Automatic unloading of unused textures based on AssetComponent::last_accessed\n\n8. **Additional Features**:\n   - Texture compression support (BC1-BC7 formats)\n   - Runtime format conversion utilities\n   - Texture array and 3D texture support\n   - Async GPU upload with fence synchronization",
        "testStrategy": "1. **Unit Tests**:\n   - Test stb_image loading for each supported format\n   - Verify correct metadata extraction (dimensions, channels)\n   - Test format conversion accuracy\n   - Validate mipmap generation levels calculation\n\n2. **Integration Tests**:\n   - Load test texture through AssetManager\n   - Verify VkImage creation and memory binding\n   - Test texture sampling in a test shader\n   - Validate hot-reload by modifying texture file\n\n3. **Performance Tests**:\n   - Benchmark loading 1000+ textures\n   - Measure GPU upload time for various sizes\n   - Test memory usage stays within budget\n   - Profile mipmap generation performance\n\n4. **Stress Tests**:\n   - Load maximum GPU memory with textures\n   - Test rapid load/unload cycles\n   - Verify no memory leaks with validation layers\n   - Test concurrent texture loading from multiple threads\n\n5. **Visual Tests**:\n   - Render test scene with loaded textures\n   - Verify correct orientation and color space\n   - Test different sampler settings (linear/nearest)\n   - Validate mipmap LOD transitions",
        "status": "pending",
        "dependencies": [],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 2,
        "title": "Implement audio asset loading system with miniaudio integration for 3D spatial audio and streaming support",
        "description": "Create a comprehensive audio asset loading system that integrates miniaudio for loading various audio formats and provides seamless 3D spatial audio processing with streaming capabilities, audio compression, and real-time effects support.",
        "details": "Implementation requires several key components:\n\n1. **Audio Asset Loader Class** (src/assets/audio_loader.hpp/cpp):\n   - Inherit from AssetLoader base class defined in include/lore/assets/assets.hpp\n   - Support formats: WAV, MP3, OGG, FLAC, PCM (using miniaudio's decoding capabilities)\n   - Handle streaming and static loading modes\n   - Convert loaded data to internal audio format (32-bit float PCM)\n   - Generate metadata including sample rate, channels, duration, format\n   - Implement extract_metadata() to read audio properties without full load\n\n2. **Audio Buffer Management** (src/audio/audio_buffer.hpp/cpp):\n   - Create AudioBuffer class for managing PCM data\n   - Support both interleaved and planar layouts\n   - Implement ring buffer for streaming audio\n   - Handle format conversions (16/24/32-bit int to float)\n   - Provide resampling capabilities for different sample rates\n\n3. **Streaming Audio System** (src/audio/audio_stream.hpp/cpp):\n   - Implement AudioStream class for real-time streaming\n   - Use miniaudio's data source API for efficient streaming\n   - Support buffered streaming with configurable chunk sizes\n   - Handle network streaming protocols (HTTP/HTTPS)\n   - Implement prefetching and double-buffering\n\n4. **3D Spatial Audio Processing** (src/audio/spatial_audio.hpp/cpp):\n   - Implement HRTF (Head-Related Transfer Function) processing\n   - Calculate distance attenuation using inverse square law\n   - Implement Doppler effect calculations\n   - Support multiple attenuation models (linear, exponential, inverse)\n   - Handle occlusion and obstruction with ray-casting\n\n5. **Asset Integration** (src/assets/audio_asset_integration.cpp):\n   - Register AudioLoader with AssetManager for audio types\n   - Map file extensions to audio formats\n   - Implement hot-reload support for audio assets\n   - Handle audio asset dependencies (e.g., reverb impulse responses)\n\n6. **Audio Memory Pool** (src/audio/audio_memory.hpp/cpp):\n   - Implement specialized memory pool for audio buffers\n   - Use aligned allocation for SIMD operations\n   - Support dynamic resizing based on streaming needs\n   - Implement audio buffer caching with LRU eviction\n\n7. **Audio Compression Support** (src/audio/audio_compression.hpp/cpp):\n   - Integrate with CompressionType from lore_package.hpp\n   - Support real-time decompression during streaming\n   - Implement lossy compression for memory optimization\n   - Handle compressed audio in asset packages\n\n8. **Miniaudio Integration Layer** (src/audio/miniaudio_backend.hpp/cpp):\n   - Wrap miniaudio device and engine functionality\n   - Implement audio graph nodes for effects processing\n   - Handle platform-specific audio backends (WASAPI, CoreAudio, ALSA)\n   - Support low-latency audio output\n\n9. **Audio Effects Pipeline** (src/audio/audio_effects.hpp/cpp):\n   - Implement effect chain processing\n   - Support reverb using miniaudio's reverb node\n   - Add EQ, compression, and limiting\n   - Enable real-time parameter modulation\n\n10. **Audio Asset Metadata** (extend BasicAssetMetadata):\n    - Add audio-specific properties: sample_rate, bit_depth, channels\n    - Store loop points and cue markers\n    - Include BPM and musical metadata\n    - Track audio codec information",
        "testStrategy": "1. **Unit Tests** (tests/audio/test_audio_loader.cpp):\n   - Test miniaudio initialization and device enumeration\n   - Verify audio format detection for WAV, MP3, OGG, FLAC\n   - Test metadata extraction without full decode\n   - Validate PCM conversion accuracy\n   - Test streaming buffer management\n   - Verify memory pool allocation and deallocation\n\n2. **Integration Tests** (tests/audio/test_audio_integration.cpp):\n   - Load audio assets through AssetManager\n   - Test simultaneous playback of multiple sources\n   - Verify 3D spatial positioning accuracy\n   - Test Doppler effect with moving sources\n   - Validate streaming performance with large files\n   - Test hot-reload of audio assets\n\n3. **Performance Tests** (tests/audio/test_audio_performance.cpp):\n   - Benchmark audio decoding speed\n   - Measure streaming latency and jitter\n   - Test CPU usage with multiple 3D sources\n   - Profile memory usage during streaming\n   - Stress test with 100+ simultaneous audio sources\n\n4. **Platform Tests** (tests/audio/test_audio_platform.cpp):\n   - Verify WASAPI backend on Windows\n   - Test exclusive mode and low-latency output\n   - Validate multi-channel output (5.1, 7.1)\n   - Test device hot-plugging handling\n\n5. **Audio Quality Tests** (tests/audio/test_audio_quality.cpp):\n   - Verify sample-accurate playback\n   - Test resampling quality (44.1kHz to 48kHz)\n   - Validate bit-depth conversions\n   - Test effect processing accuracy\n\n6. **ECS Integration Tests** (tests/audio/test_audio_ecs.cpp):\n   - Test AudioSourceComponent with AudioSystem\n   - Verify AudioListenerComponent positioning\n   - Test HearingComponent damage simulation\n   - Validate ReverbComponent zone effects",
        "status": "pending",
        "dependencies": [],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 3,
        "title": "Implement 3D model loading system with GLTF/GLB support using tinygltf for mesh and material data",
        "description": "Create a comprehensive 3D model asset loading system that integrates tinygltf for loading GLTF/GLB models and provides seamless Vulkan buffer creation with mesh data extraction, material processing, and animation support.",
        "details": "Implementation requires several key components:\n\n1. **Model Asset Loader Class** (src/assets/model_loader.hpp/cpp):\n   - Inherit from AssetLoader base class defined in include/lore/assets/assets.hpp\n   - Support formats: GLTF 2.0 (.gltf) and GLB 2.0 (.glb) using tinygltf library\n   - Parse GLTF/GLB files and extract mesh data, materials, textures, animations\n   - Convert mesh data to Vulkan-compatible vertex and index buffers\n   - Generate metadata including vertex count, triangle count, bounding box, material count\n   - Handle both ASCII (.gltf) and binary (.glb) variants\n   - Support embedded and external texture references\n   - Extract PBR material properties (base color, metallic, roughness, normal maps)\n\n2. **Vulkan Mesh Manager** (src/graphics/mesh_manager.hpp/cpp):\n   - Create VkBuffer objects for vertex and index data from loaded models\n   - Implement vertex buffer layouts supporting position, normal, UV, tangent attributes\n   - Handle multiple mesh primitives within a single GLTF node\n   - Manage GPU memory allocation using VMA or custom allocator\n   - Support interleaved and separate vertex attribute buffers\n   - Implement buffer staging for optimal GPU upload\n   - Handle different vertex formats (float, half-float, normalized integers)\n\n3. **GLTF Scene Graph** (src/assets/gltf_scene.hpp/cpp):\n   - Parse and represent GLTF node hierarchy with transforms\n   - Support node parent-child relationships and transform inheritance\n   - Calculate world matrices from local transforms\n   - Handle mesh instancing through node references\n   - Support camera and light nodes for future expansion\n   - Implement scene traversal and culling helpers\n\n4. **Material Processing** (src/graphics/material_processor.hpp/cpp):\n   - Extract PBR metallic-roughness workflow parameters\n   - Support specular-glossiness extension if present\n   - Process texture coordinates and texture transform extensions\n   - Create Vulkan descriptor sets for material parameters\n   - Handle texture loading dependencies with Task 1 (image loading system)\n   - Support material variants and double-sided rendering flags\n\n5. **Animation Support** (src/assets/animation_data.hpp/cpp):\n   - Parse skeletal animation data from GLTF\n   - Extract bone hierarchies and skinning information\n   - Store animation clips with keyframe data\n   - Support translation, rotation, scale, and morph target animations\n   - Prepare data structures for GPU skinning\n   - Handle animation interpolation methods (LINEAR, STEP, CUBICSPLINE)\n\n6. **Integration with Asset Manager**:\n   - Register ModelLoader with AssetManager using AssetType::Model\n   - Implement load(), unload(), and extract_metadata() methods\n   - Support streaming for large models through load_streaming()\n   - Handle model validation through validate() method\n   - Support hot-reload for iterative development\n   - Generate unique AssetIDs based on model file paths\n\n7. **Tinygltf Integration**:\n   - Add tinygltf to CMakeLists.txt via CPM or FetchContent\n   - Configure tinygltf with TINYGLTF_NO_STB_IMAGE (use Task 1's stb_image)\n   - Enable TINYGLTF_NO_STB_IMAGE_WRITE to avoid duplicate symbols\n   - Handle tinygltf exceptions and convert to AssetError types\n   - Support Draco mesh compression extension if needed\n\n8. **Memory Management**:\n   - Implement efficient memory pooling for mesh data\n   - Use arena allocators for temporary loading data\n   - Support LOD (Level of Detail) mesh variants\n   - Implement reference counting for shared mesh data\n   - Handle unloading and GPU memory reclamation\n\n9. **Vulkan Buffer Creation**:\n   - Create staging buffers for CPU to GPU transfers\n   - Use transfer queue for optimal buffer uploads\n   - Implement double-buffering for dynamic meshes\n   - Support compute shader access for GPU skinning\n   - Handle buffer alignment requirements\n\n10. **Error Handling**:\n    - Validate GLTF version (must be 2.0)\n    - Check required extensions support\n    - Handle missing or corrupt buffer views\n    - Validate mesh primitive modes (triangles, strips, fans)\n    - Report detailed error messages through AssetError",
        "testStrategy": "1. **Unit Tests** (tests/assets/test_model_loader.cpp):\n   - Test tinygltf initialization and configuration\n   - Verify GLTF/GLB file format detection\n   - Test metadata extraction without full model load\n   - Validate vertex and index buffer parsing\n   - Test material property extraction\n   - Verify animation data parsing\n   - Test error handling for invalid models\n\n2. **Integration Tests** (tests/integration/test_model_system.cpp):\n   - Load test models through AssetManager\n   - Verify Vulkan buffer creation and GPU upload\n   - Test model rendering with basic shaders\n   - Validate transform hierarchy calculations\n   - Test material and texture dependencies\n   - Verify memory management and unloading\n   - Test hot-reload functionality\n\n3. **Performance Tests**:\n   - Benchmark loading times for various model sizes\n   - Measure GPU upload performance\n   - Test streaming performance for large models\n   - Profile memory usage patterns\n   - Stress test with multiple concurrent loads\n\n4. **Validation Tests**:\n   - Test with Khronos GLTF sample models\n   - Validate against GLTF validator tool\n   - Test edge cases (empty models, single triangle)\n   - Verify handling of missing textures\n   - Test with various compression settings\n\n5. **Visual Tests**:\n   - Render test models and compare with reference\n   - Verify material appearance matches GLTF spec\n   - Test animation playback accuracy\n   - Validate lighting and shading correctness",
        "status": "pending",
        "dependencies": [],
        "priority": "medium",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-09-28T15:41:53.889Z",
      "updated": "2025-09-28T15:48:24.235Z",
      "description": "=Asset management and loading system development"
    }
  },
  "tooling": {
    "tasks": [
      {
        "id": 1,
        "title": "Create comprehensive .lore package creation and management tools with command-line utilities",
        "description": "Implement complete command-line tools for building, validating, and extracting .lore asset packages, providing a full suite of utilities for asset package management in the Lore engine.",
        "details": "The implementation will create a comprehensive CLI toolset for the Lore Package System, building on the existing lore_package.hpp infrastructure found at include/lore/assets/lore_package.hpp.\n\nImplementation approach:\n\n1. **Core CLI Application Structure** (src/tools/lore_pack/main.cpp):\n   - Create modular command system with subcommands: create, extract, list, validate, info, compress, merge, diff\n   - Implement argument parsing using standard C++23 features or minimal dependency library\n   - Support both interactive and batch modes\n   - Provide comprehensive help system and examples\n\n2. **Package Creation Tool** (src/tools/lore_pack/commands/create.cpp):\n   - Scan directory trees for assets using std::filesystem\n   - Auto-detect asset types from extensions using detect_asset_type_from_extension()\n   - Support manifest files (JSON/YAML) for explicit asset configuration\n   - Implement multi-threaded compression using CompressionType enum (LZ4, ZSTD, LZMA)\n   - Calculate and store integrity hashes (CRC32, SHA256, BLAKE3, XXH3)\n   - Support incremental builds and delta packages\n   - Generate comprehensive build reports\n\n3. **Package Extraction Tool** (src/tools/lore_pack/commands/extract.cpp):\n   - Extract all assets or selective extraction by ID/name/type\n   - Preserve directory structure or flatten output\n   - Parallel decompression for large packages\n   - Verify integrity during extraction using stored hashes\n   - Support partial extraction for damaged packages\n   - Generate extraction manifests\n\n4. **Package Validation Tool** (src/tools/lore_pack/commands/validate.cpp):\n   - Deep validation using LorePackage::validate_package_integrity()\n   - Check all asset checksums and hashes\n   - Validate dependency chains and detect circular dependencies\n   - Memory usage analysis and optimization suggestions\n   - Performance profiling of load times\n   - Generate detailed validation reports in multiple formats (text, JSON, HTML)\n\n5. **Package Information Tool** (src/tools/lore_pack/commands/info.cpp):\n   - Display package header information (PackageInfo)\n   - List all assets with detailed metadata (AssetInfo)\n   - Show compression statistics and ratios\n   - Visualize dependency graphs (text-based or DOT format)\n   - Memory usage predictions\n   - Asset type distribution analysis\n\n6. **Package Compression Tool** (src/tools/lore_pack/commands/compress.cpp):\n   - Recompress packages with different algorithms\n   - Optimize compression levels per asset type\n   - Batch compression testing to find optimal settings\n   - Support streaming compression for large assets\n   - Generate compression efficiency reports\n\n7. **Package Merge Tool** (src/tools/lore_pack/commands/merge.cpp):\n   - Merge multiple packages into one\n   - Handle ID conflicts with configurable strategies\n   - Deduplicate identical assets\n   - Update dependency references\n   - Support selective merging with filters\n\n8. **Package Diff Tool** (src/tools/lore_pack/commands/diff.cpp):\n   - Compare two packages for differences\n   - Show added/removed/modified assets\n   - Binary diff for asset data changes\n   - Metadata comparison\n   - Generate patch files for updates\n\n9. **Common Utilities** (src/tools/lore_pack/utils/):\n   - Progress bar implementation for long operations\n   - Colored console output for better readability\n   - Configuration file parser for tool settings\n   - Asset filter system (wildcards, regex)\n   - Performance timer and memory tracker\n   - Error handling and recovery system\n\n10. **Build System Integration** (src/tools/lore_pack/CMakeLists.txt):\n    - Create standalone executable linking against lore_assets\n    - Optional GUI using minimal dependencies (Dear ImGui)\n    - Support for plugin-based asset processors\n    - Integration with existing build tools (CMake, MSBuild)\n\n11. **Example Usage**:\n    ```bash\n    # Create package from directory\n    lore-pack create -i ./assets -o game.lore --compress lz4 --level 3\n    \n    # Extract specific assets\n    lore-pack extract game.lore -o ./output --filter \"*.tex2\" --parallel 8\n    \n    # Validate package integrity\n    lore-pack validate game.lore --deep --report validation.json\n    \n    # Show package information\n    lore-pack info game.lore --verbose --deps-graph\n    \n    # Optimize compression\n    lore-pack compress game.lore -o optimized.lore --best --per-type\n    \n    # Merge packages\n    lore-pack merge base.lore dlc1.lore dlc2.lore -o complete.lore\n    \n    # Compare packages\n    lore-pack diff old.lore new.lore --output patch.diff\n    ```\n\n12. **Integration Points**:\n    - Utilize existing LorePackage and LorePackageBuilder classes\n    - Leverage AssetMetadata for custom properties\n    - Use established error handling with Result<T> types\n    - Support all defined AssetType and CompressionType enums\n    - Integrate with AssetManager for runtime validation\n\nThe tools will be production-ready with comprehensive error handling, detailed logging, and extensive documentation, making the Lore package system accessible to both developers and content creators.",
        "testStrategy": "1. **Unit Testing**: Create comprehensive test suite in tests/tools/lore_pack/ covering each command module with mock file systems and test packages.\n\n2. **Integration Testing**: Test complete workflows including create->validate->extract cycles with real asset files of various types and sizes.\n\n3. **Performance Testing**: Benchmark compression ratios, creation speed, and extraction speed with packages ranging from 1MB to 10GB containing 1-100,000 assets.\n\n4. **Error Recovery Testing**: Test handling of corrupted packages, missing dependencies, invalid formats, and filesystem errors.\n\n5. **Cross-platform Testing**: Verify tools work correctly on Windows (MSVC), Linux (GCC/Clang), and macOS with different file systems.\n\n6. **Memory Testing**: Use valgrind/sanitizers to ensure no memory leaks during package operations, especially with large packages.\n\n7. **Regression Testing**: Create golden test packages to ensure format compatibility across versions.\n\n8. **CLI Testing**: Automated testing of all command-line arguments, flags, and combinations using test harness.\n\n9. **Validation**: Verify created packages can be loaded by AssetManager and all assets are accessible at runtime.",
        "status": "pending",
        "dependencies": [],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 2,
        "title": "Implement hot-reload file watching system for development with cross-platform filesystem monitoring and automatic asset reloading",
        "description": "Create a comprehensive file watching system that monitors asset directories for changes during development and automatically reloads modified assets in the Lore engine, with cross-platform support using native filesystem APIs.",
        "details": "The implementation will create a robust hot-reload system integrated with the existing Lore asset management infrastructure found in include/lore/assets/assets.hpp and src/assets/assets.cpp.\n\nImplementation approach:\n\n1. **Core File Watcher Architecture** (include/lore/assets/file_watcher.hpp):\n   - Design abstract FileWatcher base class with platform-specific implementations\n   - Create FileSystemEvent enum: Modified, Created, Deleted, Renamed, MetadataChanged\n   - Implement WatcherOptions struct with recursive watching, debounce timing, filter patterns\n   - Thread-safe event queue with lock-free SPSC queue for performance\n   - Event batching and coalescing to prevent redundant reloads\n\n2. **Windows Implementation** (src/assets/file_watcher_win32.cpp):\n   - Use Windows ReadDirectoryChangesW API for native monitoring\n   - Implement overlapped I/O with completion ports for scalability\n   - Handle FILE_NOTIFY_CHANGE_LAST_WRITE, FILE_NOTIFY_CHANGE_FILE_NAME events\n   - Support Unicode paths and long path names (>260 chars)\n   - Implement directory handle caching for performance\n\n3. **Linux Implementation** (src/assets/file_watcher_linux.cpp):\n   - Use inotify API for efficient kernel-level monitoring\n   - Handle IN_MODIFY, IN_CREATE, IN_DELETE, IN_MOVED_FROM/TO events\n   - Implement recursive watching with automatic inotify watch descriptor management\n   - Handle inotify descriptor limits with fallback to polling if needed\n   - Support for symlink resolution and mount point detection\n\n4. **macOS Implementation** (src/assets/file_watcher_macos.cpp):\n   - Use FSEvents API for directory monitoring\n   - Implement FSEventStreamCreate with kFSEventStreamEventFlagItemModified flags\n   - Handle file-level granularity with FSEventStreamCreateFlags\n   - Support for HFS+ and APFS specific behaviors\n   - Integrate with Core Foundation RunLoop for event delivery\n\n5. **Fallback Polling Implementation** (src/assets/file_watcher_poll.cpp):\n   - Periodic filesystem polling using std::filesystem\n   - Track file modification times, sizes, and content hashes\n   - Configurable polling intervals with adaptive frequency\n   - Memory-efficient change detection using rolling hash windows\n\n6. **Hot Reload Integration** (src/assets/hot_reload_system.cpp):\n   - Integrate with existing AssetManager class from assets.hpp\n   - Implement AssetReloader with type-specific reload strategies\n   - Asset dependency graph tracking for cascade reloading\n   - Reload transaction system with rollback on failure\n   - Preserve asset references during reload using double-buffering\n\n7. **Asset Type Handlers**:\n   - ShaderReloader: Recompile SPIR-V shaders using glslangValidator\n   - TextureReloader: Reload and recompress textures maintaining GPU residency\n   - MeshReloader: Update vertex/index buffers with format validation\n   - AudioReloader: Stream new audio data without playback interruption\n   - ConfigReloader: Parse and apply configuration changes atomically\n\n8. **Performance Optimizations**:\n   - Event debouncing with configurable delay (default 100ms)\n   - Batch processing of multiple file changes in single frame\n   - Lazy reloading with priority queue based on asset usage frequency\n   - Memory pool for file event objects to reduce allocations\n   - Lock-free queues between watcher threads and main thread\n\n9. **Error Handling and Recovery**:\n   - Graceful handling of file locks and permission errors\n   - Automatic retry with exponential backoff for transient failures\n   - Detailed error reporting with file paths and error codes\n   - Fallback to previous asset version on reload failure\n   - Watchdog timer to detect and recover from hung operations\n\n10. **Developer Tools Integration**:\n    - Real-time reload statistics overlay (files watched, reloads/sec)\n    - Console commands: reload_asset, pause_watching, force_reload_all\n    - Integration with CMake for automatic shader recompilation\n    - Debug visualization of watched directories and pending reloads\n    - Performance profiler integration for reload timing analysis\n\n11. **Thread Safety and Synchronization**:\n    - Dedicated watcher thread per root directory\n    - Thread pool for parallel asset reloading\n    - RCU (Read-Copy-Update) pattern for asset handle updates\n    - Atomic operations for reload state transitions\n    - Careful ordering of Vulkan resource updates to prevent GPU stalls\n\n12. **Configuration and Control** (extending HotReloadConfig in assets.hpp):\n    - YAML/JSON configuration file for watch patterns\n    - Runtime enable/disable without restart\n    - Per-asset-type reload strategies\n    - Ignore patterns for build artifacts and temp files\n    - Platform-specific optimizations toggles",
        "testStrategy": "1. **Unit Testing**: Create test suite in tests/assets/file_watcher/ with mock filesystem operations, simulated file events, and cross-platform behavior verification.\n\n2. **Integration Testing**: Test with real filesystem operations including rapid file modifications, large directory hierarchies, symlink handling, and permission changes.\n\n3. **Platform Testing**: Verify native implementations on Windows 10/11, Ubuntu 22.04+, macOS 12+, with fallback polling on unsupported systems.\n\n4. **Performance Testing**: Benchmark with 10,000+ files, measure CPU usage <1% idle, reload latency <16ms for small assets, memory overhead <10MB for watcher infrastructure.\n\n5. **Stress Testing**: Simulate IDE save storms, bulk file operations, network drive latencies, and filesystem errors.\n\n6. **Asset Type Testing**: Verify each asset type reloads correctly preserving runtime state and references.\n\n7. **Thread Safety Testing**: Use thread sanitizer, test concurrent modifications, verify no deadlocks or race conditions.\n\n8. **Error Recovery Testing**: Test with locked files, missing permissions, corrupted assets, and filesystem full conditions.",
        "status": "pending",
        "dependencies": [
          1
        ],
        "priority": "low",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-09-28T15:41:58.117Z",
      "updated": "2025-09-28T15:51:54.714Z",
      "description": "=Development tools and utilities for the engine"
    }
  },
  "input": {
    "tasks": [
      {
        "id": 1,
        "title": "Implement complete Input System with GLFW integration for keyboard, mouse, and gamepad input handling with event queuing and state management",
        "description": "Create a comprehensive input handling system that integrates with the existing GLFW window and Vulkan graphics pipeline, providing unified keyboard, mouse, and gamepad input with event queuing, state management, and action mapping capabilities.",
        "details": "Implementation will create a robust input system integrated with the existing Lore engine architecture:\n\n1. **Core Input System Architecture** (include/lore/input/input.hpp):\n   ```cpp\n   namespace lore::input {\n       enum class KeyCode : uint32_t { /* GLFW key mappings */ };\n       enum class MouseButton : uint8_t { Left, Right, Middle, X1, X2 };\n       enum class GamepadButton : uint16_t { /* XInput/DualShock mappings */ };\n       enum class InputAction { Press, Release, Repeat, Hold };\n       \n       struct InputEvent {\n           std::chrono::steady_clock::time_point timestamp;\n           InputDeviceType device;\n           uint32_t code;\n           InputAction action;\n           float value; // For analog inputs\n           glm::vec2 position; // For mouse/touch\n       };\n       \n       class InputSystem : public ecs::System {\n           static InputSystem& instance();\n           void initialize(GLFWwindow* window);\n           void update(World& world, float delta_time) override;\n           void process_events();\n           bool is_key_pressed(KeyCode key) const;\n           bool is_key_just_pressed(KeyCode key) const;\n           bool is_mouse_button_pressed(MouseButton button) const;\n           glm::vec2 get_mouse_position() const;\n           glm::vec2 get_mouse_delta() const;\n           float get_gamepad_axis(int gamepad, GamepadAxis axis) const;\n       };\n   }\n   ```\n\n2. **GLFW Callback Integration** (src/input/input_system.cpp):\n   - Register GLFW callbacks: glfwSetKeyCallback, glfwSetMouseButtonCallback, glfwSetCursorPosCallback, glfwSetScrollCallback, glfwSetJoystickCallback\n   - Convert GLFW events to internal InputEvent format\n   - Implement callback trampolines to access InputSystem singleton\n   - Handle window focus events for input state reset\n   - Support raw mouse motion via glfwSetInputMode(GLFW_RAW_MOUSE_MOTION)\n\n3. **Input State Management** (src/input/input_state.hpp/cpp):\n   - Maintain current and previous frame state for all inputs\n   - Implement double-buffering for thread-safe state updates\n   - Track key hold durations for repeat detection\n   - Mouse position history for delta calculation\n   - Gamepad connection/disconnection handling\n   - Dead zone configuration for analog inputs\n\n4. **Event Queue System** (src/input/event_queue.hpp/cpp):\n   - Lock-free SPSC queue for event buffering (using std::atomic)\n   - Event priority system (input events before window events)\n   - Event filtering and consumption mechanisms\n   - Time-stamped events for frame-independent processing\n   - Configurable queue size with overflow handling\n\n5. **Action Mapping System** (src/input/action_mapper.hpp/cpp):\n   ```cpp\n   class ActionMapper {\n       void bind_action(const std::string& action, KeyCode key);\n       void bind_action(const std::string& action, MouseButton button);\n       void bind_action(const std::string& action, GamepadButton button);\n       void bind_axis(const std::string& axis, KeyCode positive, KeyCode negative);\n       bool is_action_triggered(const std::string& action) const;\n       float get_axis_value(const std::string& axis) const;\n       void load_bindings(const std::string& config_file);\n   };\n   ```\n\n6. **Gamepad Support** (src/input/gamepad.hpp/cpp):\n   - Support up to 16 gamepads via GLFW joystick API\n   - XInput-style button mapping with PlayStation fallbacks\n   - Configurable dead zones per axis\n   - Vibration/force feedback support where available\n   - Gamepad capability detection (axes, buttons, hats)\n   - Automatic gamepad database updates via gamecontrollerdb.txt\n\n7. **Input Components for ECS** (include/lore/input/components.hpp):\n   ```cpp\n   struct InputReceiverComponent {\n       std::vector<std::string> subscribed_actions;\n       std::function<void(const InputEvent&)> callback;\n       int priority = 0;\n       bool consume_events = false;\n   };\n   \n   struct MouseLookComponent {\n       float sensitivity = 0.002f;\n       float max_pitch = 89.0f;\n       bool inverted_y = false;\n       glm::vec2 current_rotation;\n   };\n   ```\n\n8. **Text Input Handling** (src/input/text_input.hpp/cpp):\n   - UTF-8 text input via glfwSetCharCallback\n   - IME (Input Method Editor) support for international input\n   - Clipboard integration (copy/paste) via glfwGetClipboardString\n   - Text composition events for complex scripts\n\n9. **Platform-Specific Features**:\n   - Windows: DirectInput/XInput for enhanced gamepad support\n   - Linux: evdev for additional device support\n   - macOS: IOKit for controller vibration\n   - Touch input preparation for future mobile support\n\n10. **Integration with Graphics System**:\n    - Modify src/graphics/graphics.cpp Impl class to expose GLFWwindow pointer\n    - Add input processing before glfwPollEvents() in update loop\n    - Coordinate with framebuffer resize callback for resolution changes\n    - Handle cursor visibility and capture modes\n\n11. **Performance Optimizations**:\n    - Input event batching to reduce callback overhead\n    - SIMD operations for gamepad dead zone calculations\n    - Memory pool for InputEvent objects\n    - Compile-time key mapping via constexpr tables\n    - Zero-allocation event processing in steady state\n\n12. **Debug and Development Features**:\n    - Input recording and playback for testing\n    - Visual input debugger overlay\n    - Input latency measurement\n    - Configurable input simulation for automated testing\n\n13. **Configuration System** (config/input.ini):\n    ```ini\n    [Mouse]\n    sensitivity=0.002\n    raw_input=true\n    \n    [Gamepad]\n    dead_zone=0.15\n    vibration_enabled=true\n    \n    [Keyboard]\n    repeat_delay=500\n    repeat_rate=30\n    ```",
        "testStrategy": "Comprehensive testing approach for the input system:\n\n1. **Unit Tests** (tests/input/):\n   - Test KeyCode to GLFW mapping correctness\n   - Verify event queue overflow handling\n   - Test action mapper binding and unbinding\n   - Validate dead zone calculations\n   - Test state transition detection (just pressed/released)\n\n2. **Integration Tests**:\n   - Create test window and verify callback registration\n   - Simulate GLFW events and verify InputSystem receives them\n   - Test multiple gamepad connections/disconnections\n   - Verify thread safety of event queue with concurrent access\n   - Test integration with ECS InputReceiverComponent\n\n3. **Interactive Test Application** (examples/input_test/):\n   - Display real-time input state for all devices\n   - Show key press/release events with timestamps\n   - Visualize mouse position and delta\n   - Display gamepad axes and button states\n   - Test action mapping with configurable bindings\n\n4. **Performance Benchmarks**:\n   - Measure event processing latency\n   - Profile memory usage under high event load\n   - Benchmark SIMD vs scalar dead zone calculations\n   - Test queue performance with 10,000+ events/second\n\n5. **Platform Testing**:\n   - Verify Windows XInput gamepad support\n   - Test Linux with various gamepad types\n   - Validate macOS specific key mappings\n   - Test high-DPI mouse input scaling\n\n6. **Edge Case Testing**:\n   - Rapid key press/release sequences\n   - Window focus loss during input\n   - Gamepad disconnection during use\n   - Unicode text input with various languages\n   - Mouse capture mode transitions\n\n7. **Regression Tests**:\n   - Ensure no interference with existing graphics system\n   - Verify no memory leaks with Valgrind/AddressSanitizer\n   - Test compatibility with hot reload system\n   - Validate thread safety with ThreadSanitizer",
        "status": "pending",
        "dependencies": [],
        "priority": "high",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-09-28T15:52:23.180Z",
      "updated": "2025-09-28T16:04:47.153Z",
      "description": "=Input system for handling keyboard, mouse, and gamepad input"
    }
  },
  "entities": {
    "tasks": [
      {
        "id": 1,
        "title": "Implement complete Entity Management System with world state, entity lifecycle, and component relationships for large-scale game world simulation",
        "description": "Design and implement a comprehensive Entity Management System that extends the existing ECS framework with advanced world state management, entity lifecycle handling, and component relationship tracking to support large-scale game world simulation with 1M+ entities.",
        "details": "This task involves implementing a complete Entity Management System built on top of the existing lore::ecs foundation (defined in include/lore/ecs/ecs.hpp and src/ecs/ecs.cpp). The system must support:\n\n1. **World State Management**:\n   - Extend the existing World class with persistent world state serialization/deserialization\n   - Implement world snapshots for save/load functionality using efficient binary formats\n   - Add world delta tracking for network synchronization and replay systems\n   - Create world partitioning for spatial subdivision (octrees/quadtrees) to optimize queries\n   - Implement world streaming for infinite/large worlds with chunk-based loading\n\n2. **Entity Lifecycle Management**:\n   - Enhance EntityManager with entity templates/prefabs for rapid spawning\n   - Implement entity pooling to reduce allocation overhead (extends existing free_entities_)\n   - Add entity cloning with deep component copying\n   - Create entity hierarchies with parent-child relationships\n   - Implement deferred entity destruction for safe mid-update removal\n   - Add entity tagging and layering systems for logical grouping\n\n3. **Component Relationships**:\n   - Implement component dependency graphs for automatic ordering\n   - Create component observers for reactive programming patterns\n   - Add component constraints and validation\n   - Implement shared component instances for memory efficiency\n   - Create component versioning for change detection\n   - Add component serialization traits for save/load\n\n4. **Advanced Features**:\n   - Implement archetype-based storage optimization (leveraging ComponentBitSet)\n   - Add multi-threaded system execution with proper synchronization\n   - Create spatial queries (ray casts, sphere queries, AABB queries)\n   - Implement LOD (Level of Detail) management for entities\n   - Add entity statistics and profiling (extends existing get_entity_count())\n   - Create entity event system for lifecycle notifications\n\n5. **Integration with Existing Systems**:\n   - Integrate with lore::assets::AssetComponent for resource management\n   - Connect with physics system for spatial partitioning\n   - Link with graphics system for frustum culling\n   - Coordinate with audio system for spatial sound queries\n\nKey implementation files to modify/extend:\n   - include/lore/ecs/ecs.hpp - Extend World, EntityManager, ComponentRegistry\n   - src/ecs/ecs.cpp - Implement new functionality\n   - Create new files:\n     - include/lore/ecs/world_state.hpp - World state management\n     - include/lore/ecs/entity_lifecycle.hpp - Lifecycle extensions\n     - include/lore/ecs/component_relationships.hpp - Relationship system\n     - src/ecs/world_state.cpp\n     - src/ecs/entity_lifecycle.cpp\n     - src/ecs/component_relationships.cpp\n\nThe implementation must maintain the existing performance characteristics (1M+ entities) while adding these features. Use SIMD operations where applicable (following patterns in existing codebase), implement zero-allocation update loops using arena allocators, and ensure thread-safe operations for concurrent access.",
        "testStrategy": "1. **Unit Tests**: Create comprehensive unit tests in tests/ecs/ covering:\n   - Entity creation/destruction at scale (spawn 1M entities, verify memory usage)\n   - Component addition/removal performance (benchmark sparse set operations)\n   - World serialization round-trip (save/load with data integrity verification)\n   - Entity hierarchy operations (parent-child relationships, cascading destruction)\n   - Component dependency resolution (topological sorting verification)\n\n2. **Integration Tests**:\n   - Test entity streaming with simulated large world (10000x10000 chunks)\n   - Verify spatial queries return correct entities (octree traversal validation)\n   - Test multi-threaded system execution with race condition detection\n   - Validate entity pooling reduces allocations (memory profiling)\n\n3. **Performance Benchmarks**:\n   - Measure entity creation: target 1M entities/second\n   - Component iteration: target 10M components/frame at 60fps\n   - Spatial queries: sub-millisecond for 1000 entity results\n   - World serialization: < 1 second for 100k entities\n   - Memory usage: < 1GB for 1M entities with 5 components each\n\n4. **Stress Tests**:\n   - Spawn/destroy entities continuously for 1 hour (memory leak detection)\n   - Perform 10000 world saves/loads (data corruption testing)\n   - Execute spatial queries on 1M moving entities (spatial structure validation)\n   - Test entity limit handling at MAX_ENTITIES boundary\n\n5. **Validation**:\n   - Verify integration with existing main.cpp initialization\n   - Ensure compatibility with CMake build system\n   - Check MSVC strict warning compliance (/W4 /WX flags)\n   - Validate SIMD optimizations with performance counters",
        "status": "pending",
        "dependencies": [],
        "priority": "high",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-09-28T15:52:27.627Z",
      "updated": "2025-09-28T16:06:29.580Z",
      "description": "=Entity management and world state systems"
    }
  },
  "compute": {
    "tasks": [
      {
        "id": 1,
        "title": "Implement GPU Compute System with Vulkan compute shaders",
        "description": "Create a comprehensive Vulkan compute shader system for physics simulation, particle systems, and massive parallel processing, fully integrated with the existing Lore engine architecture.",
        "details": "Implementation will build upon the existing Vulkan graphics infrastructure in `src/graphics/graphics.cpp` and leverage the ECS system for entity management.\n\n**Key Components:**\n\n1. **Compute Pipeline Infrastructure** (`src/compute/compute.hpp/cpp`):\n   - Create `ComputeSystem` class following the singleton pattern like `GraphicsSystem`\n   - Implement compute pipeline creation with VkComputePipelineCreateInfo\n   - Add compute command pool separate from graphics (VK_QUEUE_COMPUTE_BIT)\n   - Implement compute descriptor set layouts for SSBOs and UBOs\n   - Create compute shader module loading from SPIR-V\n   - Add synchronization primitives (VkFence, VkSemaphore) for GPU-GPU sync\n\n2. **Buffer Management System** (`src/compute/buffer_manager.hpp/cpp`):\n   - Implement structured buffer (SSBO) allocation with VK_BUFFER_USAGE_STORAGE_BUFFER_BIT\n   - Create staging buffer system for CPU-GPU transfers\n   - Add buffer pool with sub-allocation for small buffers\n   - Implement triple buffering for async compute operations\n   - Memory barrier management (VkMemoryBarrier, VkBufferMemoryBarrier)\n\n3. **Physics Compute Integration** (`shaders/physics_compute.comp`):\n   - Port RigidBodyComponent updates to compute shaders\n   - Implement broad-phase collision detection using spatial hashing\n   - Narrow-phase collision with GJK/EPA algorithms in compute\n   - Constraint solver using Position Based Dynamics (PBD)\n   - Integration with existing `lore::physics::PhysicsSystem`\n\n4. **Particle System** (`src/compute/particle_system.hpp/cpp`):\n   - GPU-based particle emission and lifecycle management\n   - Particle physics (gravity, wind, collisions) in compute shaders\n   - Sorting for alpha blending using bitonic sort on GPU\n   - Integration with `lore::ecs::ComponentArray<ParticleComponent>`\n\n5. **Compute Shader Library** (`shaders/compute/`):\n   - `particle_update.comp`: Particle physics and lifecycle\n   - `physics_integrate.comp`: Verlet integration for rigid bodies\n   - `collision_broad.comp`: Spatial hash broad-phase\n   - `collision_narrow.comp`: GJK narrow-phase collision\n   - `parallel_reduce.comp`: Reduction operations (sum, min, max)\n   - `parallel_scan.comp`: Prefix sum for stream compaction\n\n6. **SIMD-Compute Bridge** (`src/compute/simd_bridge.hpp/cpp`):\n   - Convert between CPU SIMD types (Vec3SIMD, Mat4SIMD) and GPU buffers\n   - Batch operations for transforming entity data\n   - Integration with `lore::math::simd` namespace\n\n7. **Resource Management**:\n   - Implement compute resource pools (descriptor sets, buffers)\n   - Add profiling with VK_KHR_performance_query\n   - GPU memory management with VMA (Vulkan Memory Allocator)\n\n8. **CMake Integration**:\n   - Update CMakeLists.txt to compile compute shaders\n   - Add compute shader validation in debug builds\n   - Configure shader hot-reloading for development\n\n**Technical Specifications:**\n- Use Vulkan 1.3 compute features (subgroup operations, descriptor indexing)\n- Workgroup size optimization (typically 64 or 256 threads)\n- Shared memory usage for cache-friendly algorithms\n- Push constants for small uniform data\n- Async compute with dedicated compute queue\n- Support for indirect dispatch (GPU-driven rendering)",
        "testStrategy": "1. **Unit Tests** (`tests/compute/`):\n   - Test compute pipeline creation and destruction\n   - Verify buffer allocation and data transfer correctness\n   - Test synchronization between compute and graphics queues\n   - Validate shader compilation and SPIR-V generation\n\n2. **Integration Tests**:\n   - Spawn 100,000 particles and verify update performance < 1ms\n   - Test physics simulation with 10,000 rigid bodies at 60 FPS\n   - Verify collision detection accuracy with known test cases\n   - Test CPU-GPU data consistency after compute operations\n\n3. **Performance Benchmarks**:\n   - Measure compute dispatch overhead\n   - Profile memory bandwidth utilization\n   - Compare CPU vs GPU physics performance (expect 10-50x speedup)\n   - Test scaling with different workload sizes\n\n4. **Validation Layer Testing**:\n   - Enable Vulkan validation layers (VK_LAYER_KHRONOS_validation)\n   - Check for synchronization errors\n   - Verify no memory leaks with VMA stats\n   - Test error handling for invalid compute operations\n\n5. **Visual Testing**:\n   - Render particle systems to verify correct behavior\n   - Visualize physics debug data (collision shapes, velocities)\n   - Test with RenderDoc for GPU debugging\n\n6. **Stress Testing**:\n   - Maximum particle count before performance degradation\n   - Physics stability with extreme forces/velocities\n   - Memory pressure testing with multiple compute systems\n   - Queue family switching performance",
        "status": "pending",
        "dependencies": [],
        "priority": "medium",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-09-28T15:52:32.089Z",
      "updated": "2025-09-28T16:08:37.012Z",
      "description": "=GPU compute shaders for physics and simulation"
    }
  }
}
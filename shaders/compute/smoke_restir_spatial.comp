#version 450

/**
 * ReSTIR Spatial Resampling for Smoke
 *
 * NVIDIA ReSTIR (2025): Reservoir-based Spatiotemporal Importance Resampling
 * Spatial pass: Sample nearby voxels' light reservoirs for better lighting
 *
 * Enables high-quality multi-light illumination of volumetric smoke
 * with minimal samples (8 spatial neighbors vs 100+ light samples).
 *
 * Algorithm:
 * 1. For each voxel, sample N nearby voxel reservoirs
 * 2. Combine using weighted reservoir sampling (WRS)
 * 3. Store result in spatial reservoir for temporal reuse
 *
 * Reference: NVIDIA Research 2020-2025 ReSTIR papers
 */

layout(local_size_x = 8, local_size_y = 8, local_size_z = 8) in;

// Input density
layout(binding = 0) uniform sampler3D density;

// Input previous reservoirs (from last frame)
layout(binding = 1) uniform sampler3D reservoirs_in;

// Output spatial reservoirs
layout(binding = 2, rgba32f) uniform image3D spatial_reservoirs;

// Light information (from AtmosphericComponent and other light sources)
layout(push_constant) uniform ReSTIRSpatialParams {
    vec3 primary_light_direction;  // Sun/primary light
    float primary_light_intensity;
    vec3 primary_light_color;
    float _pad0;
    vec3 ambient_light_color;
    float ambient_intensity;
    uint num_spatial_samples;  // Typically 8
    float spatial_radius;      // Sampling radius in voxels
    uvec3 resolution;
    uint frame_number;         // For random seed
} params;

// Simple hash for random number generation
float hash(uvec3 coord, uint seed) {
    uint h = coord.x ^ (coord.y << 8) ^ (coord.z << 16) ^ seed;
    h = h * 1103515245u + 12345u;
    return float(h) * (1.0 / 4294967296.0);
}

// Sample light contribution at voxel
vec3 sample_light_contribution(vec3 voxel_pos, float density_value) {
    if (density_value < 0.01) {
        return vec3(0.0);
    }

    // Primary directional light (sun)
    // In full implementation, would raymarch to check occlusion
    // For now, simple Lambert
    vec3 direct_light = params.primary_light_color *
                        params.primary_light_intensity *
                        density_value;

    // Ambient light
    vec3 ambient_light = params.ambient_light_color *
                         params.ambient_intensity *
                         density_value;

    return direct_light + ambient_light;
}

void main() {
    ivec3 coord = ivec3(gl_GlobalInvocationID.xyz);

    if (coord.x >= int(params.resolution.x) ||
        coord.y >= int(params.resolution.y) ||
        coord.z >= int(params.resolution.z)) {
        return;
    }

    vec3 texel_size = 1.0 / vec3(params.resolution);
    vec3 uv = (vec3(coord) + 0.5) * texel_size;

    // Sample center density
    float center_density = texture(density, uv).r;

    if (center_density < 0.001) {
        // Empty voxel, skip
        imageStore(spatial_reservoirs, coord, vec4(0));
        return;
    }

    // Initialize reservoir
    vec3 reservoir_light = vec3(0);
    float reservoir_weight = 0.0;
    int reservoir_samples = 0;

    // Sample current voxel
    vec3 center_light = sample_light_contribution(vec3(coord), center_density);
    reservoir_light = center_light;
    reservoir_weight = 1.0;
    reservoir_samples = 1;

    // Spatial resampling: sample nearby voxels
    for (uint i = 0; i < params.num_spatial_samples; ++i) {
        // Random offset within spatial radius
        float rand1 = hash(uvec3(coord), params.frame_number + i * 7);
        float rand2 = hash(uvec3(coord), params.frame_number + i * 7 + 1);
        float rand3 = hash(uvec3(coord), params.frame_number + i * 7 + 2);

        vec3 offset = (vec3(rand1, rand2, rand3) * 2.0 - 1.0) * params.spatial_radius;
        ivec3 neighbor_coord = coord + ivec3(offset);

        // Bounds check
        if (neighbor_coord.x < 0 || neighbor_coord.x >= int(params.resolution.x) ||
            neighbor_coord.y < 0 || neighbor_coord.y >= int(params.resolution.y) ||
            neighbor_coord.z < 0 || neighbor_coord.z >= int(params.resolution.z)) {
            continue;
        }

        vec3 neighbor_uv = (vec3(neighbor_coord) + 0.5) * texel_size;
        float neighbor_density = texture(density, neighbor_uv).r;

        if (neighbor_density < 0.001) {
            continue;
        }

        // Sample neighbor's previous reservoir
        vec4 neighbor_reservoir = texture(reservoirs_in, neighbor_uv);
        vec3 neighbor_light = neighbor_reservoir.rgb;
        float neighbor_weight = neighbor_reservoir.a;

        // Weighted reservoir sampling (WRS)
        // Combine with current reservoir
        float combined_weight = reservoir_weight + neighbor_weight;
        if (combined_weight > 0.0) {
            float rand_wrs = hash(uvec3(coord), params.frame_number + i * 11 + 5);
            if (rand_wrs < neighbor_weight / combined_weight) {
                reservoir_light = neighbor_light;
            }
            reservoir_weight = combined_weight;
            reservoir_samples++;
        }
    }

    // Normalize by number of samples for unbiased estimate
    if (reservoir_samples > 0) {
        reservoir_weight /= float(reservoir_samples);
    }

    // Store spatial reservoir
    imageStore(spatial_reservoirs, coord, vec4(reservoir_light, reservoir_weight));
}
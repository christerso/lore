#version 450

// GPU Audio Source Update Compute Shader
// Handles bulk updates of all audio sources with complete GPU autonomy
layout(local_size_x = 64, local_size_y = 1, local_size_z = 1) in;

#define PI 3.14159265359
#define SPEED_OF_SOUND 343.0

struct AudioSourceData {
    uint is_playing;
    uint is_paused;
    uint was_playing;
    float volume;

    float pitch;
    vec3 position;

    vec3 velocity;
    float distance_attenuation;

    float calculated_left_gain;
    float calculated_right_gain;
    float doppler_pitch_shift;
    float phase;

    float min_distance;
    float max_distance;
    float rolloff_factor;
    uint padding;
};

struct AudioListener {
    vec3 position;
    float gain;
    vec3 velocity;
    float padding1;
    vec3 forward;
    float padding2;
    vec3 up;
    uint is_active;
};

struct AcousticMaterial {
    float absorption_coefficient;
    float transmission_coefficient;
    float scattering_coefficient;
    float density;

    float impedance;
    vec3 frequency_absorption;

    vec3 frequency_transmission;
    float roughness;

    vec3 frequency_scattering;
    float porosity;

    float hardness;
    float resonance_frequency;
    float resonance_damping;
    float resonance_amplitude;

    float temperature_sensitivity;
    float humidity_sensitivity;
    uint reflection_model;  // 0=Specular, 1=Diffuse, 2=Mixed, 3=Lambertian
    float specular_ratio;

    vec3 surface_color;
    uint padding;
};

layout(set = 0, binding = 0, std430) restrict buffer AudioSourceBuffer {
    AudioSourceData audio_sources[];
};

layout(set = 0, binding = 1, std430) restrict buffer ListenerBuffer {
    AudioListener listeners[];
};

layout(set = 0, binding = 2, std430) restrict buffer AcousticMediumBuffer {
    AcousticMaterial acoustic_medium;
};

layout(push_constant) uniform PushConstants {
    uint num_sources;
    uint num_listeners;
    float delta_time;
    float sound_speed;
    float doppler_factor;
    float master_volume;
    float time;
    uint padding;
} push_constants;

// Distance attenuation functions
float inverse_distance_attenuation(float distance, float min_distance, float max_distance) {
    if (distance <= min_distance) return 1.0;
    if (distance >= max_distance) return 0.0;
    return min_distance / distance;
}

float linear_distance_attenuation(float distance, float min_distance, float max_distance) {
    if (distance <= min_distance) return 1.0;
    if (distance >= max_distance) return 0.0;
    return 1.0 - (distance - min_distance) / (max_distance - min_distance);
}

float exponential_distance_attenuation(float distance, float min_distance, float rolloff_factor) {
    if (distance <= min_distance) return 1.0;
    float attenuation = min_distance / (min_distance + rolloff_factor * (distance - min_distance));
    return attenuation;
}

// Doppler effect calculation
float calculate_doppler_shift(vec3 source_velocity, vec3 listener_velocity,
                             vec3 source_to_listener, float sound_speed) {
    if (length(source_to_listener) < 1e-6) return 1.0;

    vec3 direction = normalize(source_to_listener);

    float source_speed = dot(source_velocity, direction);
    float listener_speed = dot(listener_velocity, direction);

    float relative_speed = listener_speed - source_speed;
    float doppler_factor = (sound_speed + relative_speed) / sound_speed;

    return clamp(doppler_factor, 0.5, 2.0); // Clamp to reasonable range
}

// Acoustic medium effects
void apply_acoustic_medium_effects(inout AudioSourceData source_data, float distance) {
    // Apply frequency-dependent attenuation based on acoustic medium
    float absorption_factor = exp(-acoustic_medium.absorption_coefficient * distance);
    source_data.distance_attenuation *= absorption_factor;

    // Apply scattering effects
    float scattering_factor = 1.0 - acoustic_medium.scattering_coefficient * distance * 0.001;
    source_data.distance_attenuation *= max(scattering_factor, 0.1);

    // Apply transmission effects for sound traveling through medium
    float transmission_factor = 1.0 - acoustic_medium.transmission_coefficient * 0.1;
    source_data.distance_attenuation *= transmission_factor;
}

// Advanced 3D spatial audio processing
void process_3d_audio(inout AudioSourceData source_data, AudioListener listener) {
    vec3 source_to_listener = listener.position - source_data.position;
    float distance = length(source_to_listener);

    if (distance > 1e-6) {
        // Calculate distance attenuation using exponential model for realism
        source_data.distance_attenuation = exponential_distance_attenuation(
            distance, source_data.min_distance, source_data.rolloff_factor);

        // Calculate stereo positioning
        vec3 listener_right = cross(listener.forward, listener.up);
        vec3 source_direction = source_to_listener / distance;

        float dot_right = dot(source_direction, listener_right);
        float dot_front = dot(source_direction, listener.forward);

        // Enhanced stereo positioning with realistic HRTF approximation
        float azimuth = atan(dot_right, dot_front);
        source_data.calculated_left_gain = 0.5 + 0.5 * cos(azimuth + PI * 0.25);
        source_data.calculated_right_gain = 0.5 + 0.5 * cos(azimuth - PI * 0.25);

        // Apply head shadowing effect for high frequencies
        float head_shadow = 1.0 - 0.3 * abs(sin(azimuth));
        if (azimuth > 0) {
            source_data.calculated_left_gain *= head_shadow;
        } else {
            source_data.calculated_right_gain *= head_shadow;
        }

        // Calculate Doppler effect
        source_data.doppler_pitch_shift = calculate_doppler_shift(
            source_data.velocity, listener.velocity,
            source_to_listener, push_constants.sound_speed);

        // Apply acoustic medium effects
        apply_acoustic_medium_effects(source_data, distance);

        // Apply elevation effects
        float elevation = asin(clamp(dot(source_direction, listener.up), -1.0, 1.0));
        float elevation_factor = cos(elevation * 0.5); // Reduced volume above/below listener
        source_data.calculated_left_gain *= elevation_factor;
        source_data.calculated_right_gain *= elevation_factor;

    } else {
        // Source at listener position
        source_data.distance_attenuation = 1.0;
        source_data.calculated_left_gain = 0.5;
        source_data.calculated_right_gain = 0.5;
        source_data.doppler_pitch_shift = 1.0;
    }

    // Apply listener gain
    source_data.calculated_left_gain *= listener.gain;
    source_data.calculated_right_gain *= listener.gain;

    // Apply master volume
    source_data.calculated_left_gain *= push_constants.master_volume;
    source_data.calculated_right_gain *= push_constants.master_volume;

    // Update phase for audio generation (test tones)
    if (source_data.is_playing != 0 && source_data.is_paused == 0) {
        float frequency = 440.0 * source_data.pitch * source_data.doppler_pitch_shift;
        source_data.phase += 2.0 * PI * frequency * push_constants.delta_time;

        // Keep phase in reasonable range
        if (source_data.phase > 2.0 * PI) {
            source_data.phase = mod(source_data.phase, 2.0 * PI);
        }
    }
}

// Environmental occlusion and reflection simulation
float calculate_environmental_occlusion(vec3 source_pos, vec3 listener_pos) {
    // Simplified occlusion calculation
    // In a full implementation, this would raycast through the environment
    vec3 direction = listener_pos - source_pos;
    float distance = length(direction);

    // Simple distance-based occlusion
    float occlusion_factor = 1.0;

    // Add slight occlusion for very close sources (head shadowing)
    if (distance < 0.5) {
        occlusion_factor = 0.8 + 0.2 * (distance / 0.5);
    }

    return occlusion_factor;
}

// Advanced reverb calculation based on environment
float calculate_environmental_reverb(vec3 source_pos, vec3 listener_pos) {
    float distance = length(listener_pos - source_pos);

    // Simulate room reverb based on distance and acoustic medium
    float room_factor = acoustic_medium.scattering_coefficient;
    float reverb_amount = room_factor * clamp(distance / 10.0, 0.0, 1.0);

    return reverb_amount;
}

void main() {
    uint source_idx = gl_GlobalInvocationID.x;

    if (source_idx >= push_constants.num_sources || source_idx >= audio_sources.length()) {
        return;
    }

    AudioSourceData source_data = audio_sources[source_idx];

    // Find the active listener
    AudioListener active_listener;
    bool listener_found = false;

    for (uint i = 0; i < push_constants.num_listeners && i < listeners.length(); ++i) {
        if (listeners[i].is_active != 0) {
            active_listener = listeners[i];
            listener_found = true;
            break;
        }
    }

    if (!listener_found) {
        // No active listener - apply default processing
        source_data.calculated_left_gain = source_data.volume * 0.5;
        source_data.calculated_right_gain = source_data.volume * 0.5;
        source_data.distance_attenuation = 1.0;
        source_data.doppler_pitch_shift = 1.0;
    } else {
        // Process 3D spatial audio with active listener
        process_3d_audio(source_data, active_listener);

        // Apply environmental effects
        float occlusion = calculate_environmental_occlusion(source_data.position, active_listener.position);
        source_data.calculated_left_gain *= occlusion;
        source_data.calculated_right_gain *= occlusion;

        float reverb = calculate_environmental_reverb(source_data.position, active_listener.position);
        // Reverb would be applied in post-processing, here we just calculate the amount
    }

    // Apply final volume scaling
    source_data.calculated_left_gain *= source_data.volume;
    source_data.calculated_right_gain *= source_data.volume;

    // Clamp gains to valid range
    source_data.calculated_left_gain = clamp(source_data.calculated_left_gain, 0.0, 2.0);
    source_data.calculated_right_gain = clamp(source_data.calculated_right_gain, 0.0, 2.0);

    // Write back updated source data
    audio_sources[source_idx] = source_data;
}
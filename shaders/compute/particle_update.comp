#version 450

/**
 * GPU Particle Update Shader
 *
 * Updates all particles entirely on GPU using compute shaders.
 * Zero CPU intervention for performance.
 *
 * Physics:
 * - Euler integration: p_new = p + v*dt, v_new = v + a*dt
 * - Forces: gravity, drag, buoyancy, wind
 * - Lifetime tracking and recycling
 *
 * Particle Data Structure (per particle):
 * - position (vec3)
 * - velocity (vec3)
 * - age (float)
 * - lifetime (float)
 * - size (float)
 * - temperature (float)
 * - rotation (float)
 * - angular_velocity (float)
 */

layout(local_size_x = 256) in;

// Particle buffer (read-write)
struct Particle {
    vec3 position;
    float age;
    vec3 velocity;
    float lifetime;
    float size;
    float temperature;
    float rotation;
    float angular_velocity;
};

layout(std430, binding = 0) buffer ParticleBuffer {
    Particle particles[];
};

// Particle count (read-write)
layout(std430, binding = 1) buffer ParticleCount {
    uint active_count;
    uint dead_count;
    uint spawn_queue;
    uint _pad;
};

layout(push_constant) uniform UpdateParams {
    // Time
    float delta_time_s;
    float time_elapsed_s;

    // Spawning
    vec3 spawn_position;
    float spawn_radius;
    vec3 spawn_velocity;
    float velocity_randomness;
    float spawn_rate;
    float lifetime_min;
    float lifetime_max;

    // Physics
    float gravity;
    float drag;
    float buoyancy_strength;
    float particle_mass;
    vec3 wind_velocity;
    float wind_turbulence;

    // Visual
    float size_start;
    float size_end;
    float rotation_speed;
    float temperature_decay_rate;

    // Config
    uint max_particles;
    uint frame_number;  // For random seed
} params;

// Simple hash for random numbers
float hash(uint seed) {
    seed = (seed ^ 61u) ^ (seed >> 16u);
    seed *= 9u;
    seed = seed ^ (seed >> 4u);
    seed *= 0x27d4eb2du;
    seed = seed ^ (seed >> 15u);
    return float(seed) * (1.0 / 4294967296.0);
}

// Random in range
float rand_range(uint seed, float min_val, float max_val) {
    return mix(min_val, max_val, hash(seed));
}

// Random unit vector
vec3 rand_unit_vec(uint seed) {
    float theta = rand_range(seed, 0.0, 6.28318530718);  // 0 to 2π
    float phi = rand_range(seed + 1u, -1.0, 1.0);
    float r = sqrt(1.0 - phi * phi);
    return vec3(r * cos(theta), phi, r * sin(theta));
}

// Initialize new particle
void spawn_particle(uint index, uint seed) {
    Particle p;

    // Position within spawn radius
    vec3 offset = rand_unit_vec(seed) * rand_range(seed + 2u, 0.0, params.spawn_radius);
    p.position = params.spawn_position + offset;

    // Velocity with randomness
    if (params.velocity_randomness > 0.01) {
        vec3 random_dir = rand_unit_vec(seed + 3u);
        float random_mag = rand_range(seed + 4u, 0.5, 1.5);
        p.velocity = mix(
            params.spawn_velocity,
            random_dir * length(params.spawn_velocity) * random_mag,
            params.velocity_randomness
        );
    } else {
        p.velocity = params.spawn_velocity;
    }

    // Lifetime
    p.age = 0.0;
    p.lifetime = rand_range(seed + 5u, params.lifetime_min, params.lifetime_max);

    // Size
    p.size = params.size_start;

    // Temperature (start value from component)
    p.temperature = 293.15;  // Will be set from spawn parameters

    // Rotation
    p.rotation = rand_range(seed + 6u, 0.0, 6.28318530718);
    p.angular_velocity = params.rotation_speed * rand_range(seed + 7u, -1.0, 1.0);

    particles[index] = p;
}

void main() {
    uint index = gl_GlobalInvocationID.x;

    if (index >= params.max_particles) {
        return;
    }

    Particle p = particles[index];

    // Check if particle is alive
    bool is_alive = p.age < p.lifetime;

    if (!is_alive) {
        // Dead particle - try to spawn new one
        // Spawn based on spawn rate
        float spawn_probability = params.spawn_rate * params.delta_time_s / float(params.max_particles);
        uint seed = index + params.frame_number * 7919u;

        if (hash(seed) < spawn_probability) {
            spawn_particle(index, seed);
            atomicAdd(active_count, 1);
            return;
        }

        return;  // Stay dead
    }

    // Update age
    p.age += params.delta_time_s;

    if (p.age >= p.lifetime) {
        // Just died
        atomicSub(active_count, 1);
        return;
    }

    // ========================================================================
    // PHYSICS UPDATE
    // ========================================================================

    // Gravity force
    vec3 force = vec3(0.0, params.gravity * params.particle_mass, 0.0);

    // Drag force: F = -k*v²
    vec3 drag_force = -params.drag * p.velocity * length(p.velocity);
    force += drag_force;

    // Buoyancy (for hot particles like smoke/embers)
    if (p.temperature > 293.15) {  // Hotter than ambient (20°C)
        float temp_diff = p.temperature - 293.15;
        vec3 buoyancy_force = vec3(0.0, temp_diff * params.buoyancy_strength * 0.001, 0.0);
        force += buoyancy_force;
    }

    // Wind force
    if (length(params.wind_velocity) > 0.01) {
        vec3 wind_force = params.wind_velocity * params.particle_mass * 5.0;

        // Add turbulence
        if (params.wind_turbulence > 0.01) {
            uint seed = index + uint(params.time_elapsed_s * 10.0);
            vec3 turbulence = rand_unit_vec(seed) * params.wind_turbulence;
            wind_force += turbulence * params.particle_mass;
        }

        force += wind_force;
    }

    // Acceleration: a = F / m
    vec3 acceleration = force / params.particle_mass;

    // Euler integration
    p.velocity += acceleration * params.delta_time_s;
    p.position += p.velocity * params.delta_time_s;

    // ========================================================================
    // VISUAL UPDATES
    // ========================================================================

    // Size lerp (start to end over lifetime)
    float life_t = p.age / p.lifetime;
    p.size = mix(params.size_start, params.size_end, life_t);

    // Temperature decay
    if (p.temperature > 293.15) {
        p.temperature -= params.temperature_decay_rate * params.delta_time_s;
        p.temperature = max(p.temperature, 293.15);
    }

    // Rotation
    p.rotation += p.angular_velocity * params.delta_time_s;

    // Write back
    particles[index] = p;
}
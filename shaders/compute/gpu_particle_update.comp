#version 450

// GPU Particle System Update Compute Shader
// Handles 1M+ particles with complete GPU autonomy
layout(local_size_x = 64, local_size_y = 1, local_size_z = 1) in;

struct Particle {
    vec3 position;
    float life;
    vec3 velocity;
    float max_life;
    vec3 acceleration;
    float size;
    vec4 color;
    uint emitter_id;
    uint padding[3];
};

struct ParticleEmitter {
    vec3 position;
    float emission_rate;
    vec3 velocity_base;
    float velocity_variation;
    vec3 acceleration;
    float life_time;
    vec4 color_start;
    vec4 color_end;
    float size_start;
    float size_end;
    uint max_particles;
    uint active_particles;
    uint padding[2];
};

layout(set = 0, binding = 0, std430) restrict buffer ParticleBuffer {
    Particle particles[];
};

layout(set = 0, binding = 1, std430) restrict buffer EmitterBuffer {
    ParticleEmitter emitters[];
};

layout(set = 0, binding = 2, std430) restrict buffer AliveListBuffer {
    uint alive_list[];
};

layout(set = 0, binding = 3, std430) restrict buffer DeadListBuffer {
    uint dead_list[];
};

layout(set = 0, binding = 4, std430) restrict buffer CountersBuffer {
    uint alive_count;
    uint dead_count;
    uint particles_to_spawn;
    uint padding;
} counters;

layout(push_constant) uniform PushConstants {
    float delta_time;
    uint max_particles;
    vec3 gravity;
    float time;
} push_constants;

// Simple hash function for randomness
uint hash(uint x) {
    x = ((x >> 16) ^ x) * 0x45d9f3b;
    x = ((x >> 16) ^ x) * 0x45d9f3b;
    x = (x >> 16) ^ x;
    return x;
}

float random(uint seed) {
    return float(hash(seed)) / 4294967295.0;
}

vec3 random_vec3(uint seed) {
    return vec3(
        random(seed) * 2.0 - 1.0,
        random(seed + 1) * 2.0 - 1.0,
        random(seed + 2) * 2.0 - 1.0
    );
}

void main() {
    uint particle_idx = gl_GlobalInvocationID.x;

    if (particle_idx >= push_constants.max_particles || particle_idx >= particles.length()) {
        return;
    }

    Particle particle = particles[particle_idx];

    // Check if particle is alive
    if (particle.life > 0.0) {
        // Update existing particle
        float dt = push_constants.delta_time;

        // Update life
        particle.life -= dt;

        if (particle.life > 0.0) {
            // Particle still alive - update physics
            float life_ratio = particle.life / particle.max_life;

            // Update velocity with acceleration
            particle.velocity += (particle.acceleration + push_constants.gravity) * dt;

            // Update position
            particle.position += particle.velocity * dt;

            // Get emitter data for interpolation
            if (particle.emitter_id < emitters.length()) {
                ParticleEmitter emitter = emitters[particle.emitter_id];

                // Interpolate color based on life
                particle.color = mix(emitter.color_end, emitter.color_start, life_ratio);

                // Interpolate size based on life
                particle.size = mix(emitter.size_end, emitter.size_start, life_ratio);
            }

            // Write updated particle
            particles[particle_idx] = particle;
        } else {
            // Particle died - add to dead list
            particle.life = 0.0;
            particle.size = 0.0;
            particles[particle_idx] = particle;

            // Atomically add to dead list
            uint dead_idx = atomicAdd(counters.dead_count, 1);
            if (dead_idx < dead_list.length()) {
                dead_list[dead_idx] = particle_idx;
            }

            // Decrease active particle count for emitter
            if (particle.emitter_id < emitters.length()) {
                atomicAdd(emitters[particle.emitter_id].active_particles, -1);
            }
        }
    } else {
        // Check if we should spawn a new particle here
        uint spawn_idx = atomicAdd(counters.particles_to_spawn, -1);
        if (spawn_idx > 0 && spawn_idx <= counters.particles_to_spawn + 1) {
            // Find an emitter that wants to spawn particles
            for (uint emitter_idx = 0; emitter_idx < emitters.length(); ++emitter_idx) {
                ParticleEmitter emitter = emitters[emitter_idx];

                if (emitter.active_particles < emitter.max_particles) {
                    // This emitter can spawn particles
                    uint seed = particle_idx + uint(push_constants.time * 1000.0) + emitter_idx * 12345;

                    // Create new particle
                    particle.position = emitter.position;
                    particle.life = emitter.life_time;
                    particle.max_life = emitter.life_time;

                    // Random velocity variation
                    vec3 random_vel = random_vec3(seed) * emitter.velocity_variation;
                    particle.velocity = emitter.velocity_base + random_vel;

                    particle.acceleration = emitter.acceleration;
                    particle.color = emitter.color_start;
                    particle.size = emitter.size_start;
                    particle.emitter_id = emitter_idx;

                    // Update particle and add to alive list
                    particles[particle_idx] = particle;

                    uint alive_idx = atomicAdd(counters.alive_count, 1);
                    if (alive_idx < alive_list.length()) {
                        alive_list[alive_idx] = particle_idx;
                    }

                    // Increase active particle count for emitter
                    atomicAdd(emitters[emitter_idx].active_particles, 1);
                    break;
                }
            }
        }
    }
}
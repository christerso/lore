#version 450

// Equirectangular to Cubemap Conversion Compute Shader
// Converts an equirectangular HDR image to a cubemap by sampling using spherical coordinates

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

layout(set = 0, binding = 0) uniform sampler2D equirectangularMap;
layout(set = 0, binding = 1, rgba16f) uniform writeonly imageCube environmentCubemap;

layout(push_constant) uniform PushConstants {
    uint faceIndex; // 0-5: +X, -X, +Y, -Y, +Z, -Z
} pc;

const float PI = 3.14159265359;
const float TWO_PI = 6.28318530718;

// Convert cubemap face coordinates to world-space direction vector
vec3 get_cubemap_direction(uint face, vec2 uv) {
    // UV ranges from 0 to 1, convert to -1 to 1
    vec2 st = uv * 2.0 - 1.0;

    vec3 direction;

    switch (face) {
        case 0: // +X
            direction = vec3(1.0, -st.y, -st.x);
            break;
        case 1: // -X
            direction = vec3(-1.0, -st.y, st.x);
            break;
        case 2: // +Y
            direction = vec3(st.x, 1.0, st.y);
            break;
        case 3: // -Y
            direction = vec3(st.x, -1.0, -st.y);
            break;
        case 4: // +Z
            direction = vec3(st.x, -st.y, 1.0);
            break;
        case 5: // -Z
            direction = vec3(-st.x, -st.y, -1.0);
            break;
    }

    return normalize(direction);
}

// Convert direction vector to equirectangular UV coordinates
vec2 direction_to_equirect_uv(vec3 direction) {
    // Spherical coordinates
    float phi = atan(direction.z, direction.x); // Azimuthal angle [-PI, PI]
    float theta = asin(direction.y);            // Polar angle [-PI/2, PI/2]

    // Convert to UV [0, 1]
    vec2 uv;
    uv.x = phi / TWO_PI + 0.5;
    uv.y = theta / PI + 0.5;

    return uv;
}

void main() {
    ivec2 cubemap_size = imageSize(environmentCubemap);
    ivec2 pixel_coords = ivec2(gl_GlobalInvocationID.xy);

    // Bounds check
    if (pixel_coords.x >= cubemap_size.x || pixel_coords.y >= cubemap_size.y) {
        return;
    }

    // Normalize pixel coordinates to [0, 1]
    vec2 uv = (vec2(pixel_coords) + 0.5) / vec2(cubemap_size);

    // Get direction vector for this cubemap pixel
    vec3 direction = get_cubemap_direction(pc.faceIndex, uv);

    // Convert direction to equirectangular UV
    vec2 equirect_uv = direction_to_equirect_uv(direction);

    // Sample equirectangular map
    vec4 color = texture(equirectangularMap, equirect_uv);

    // Write to cubemap face
    imageStore(environmentCubemap, ivec3(pixel_coords, pc.faceIndex), color);
}
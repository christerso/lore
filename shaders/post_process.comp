#version 450
#extension GL_ARB_separate_shader_objects : enable

/**
 * @brief Post-processing compute shader
 *
 * Complete post-processing pipeline:
 * 1. HDR tone mapping (multiple operators)
 * 2. Color grading (temperature, tint, saturation, contrast)
 * 3. Color balance (lift/gamma/gain)
 * 4. Vignette effect
 * 5. Dithering (prevents color banding)
 *
 * Mathematical References:
 * - ACES: Narkowicz 2015, "ACES Filmic Tone Mapping Curve"
 *   https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/
 * - Reinhard: Reinhard et al. 2002, "Photographic Tone Reproduction"
 * - Uncharted 2: Hable 2010, "Uncharted 2: HDR Lighting"
 *   http://filmicworlds.com/blog/filmic-tonemapping-operators/
 * - Color Temperature: Planckian locus approximation
 *   Tanner Helland, "Color Temperature to RGB"
 * - Lift/Gamma/Gain: ASC CDL (American Society of Cinematographers Color Decision List)
 * - Dithering: TPDF (Triangular Probability Density Function)
 */

// Workgroup size: 8×8 threads (optimized for most GPUs)
layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

// ============================================================================
// BINDINGS
// ============================================================================

// Binding 0: HDR input image (sampled, RGBA16F)
layout(binding = 0) uniform sampler2D u_hdr_input;

// Binding 1: LDR output image (storage, RGBA8)
layout(binding = 1, rgba8) uniform writeonly image2D u_ldr_output;

// Binding 2: Uniform buffer (configuration)
layout(binding = 2, std140) uniform UniformBuffer {
    // Tone mapping
    uint tone_mapping_mode;     // 0=Linear, 1=Reinhard, 2=ReinhardExt, 3=ACES, 4=Uncharted2, 5=Hejl2015
    float exposure;             // Exposure multiplier (2^EV)
    float white_point;          // White point for Reinhard Extended
    uint _pad0;

    // Color grading
    float temperature;          // Color temperature (-1 to +1)
    float tint;                 // Green/Magenta tint (-1 to +1)
    float saturation;           // Saturation multiplier
    float vibrance;             // Vibrance

    float contrast;             // Contrast
    float brightness;           // Brightness offset
    float gamma;                // Gamma correction
    uint _pad1;

    // Color balance (lift/gamma/gain)
    vec3 lift;                  // Shadows
    float _pad2;
    vec3 gamma_color;           // Midtones
    float _pad3;
    vec3 gain;                  // Highlights
    float _pad4;

    // Vignette
    float vignette_intensity;   // Vignette strength
    float vignette_smoothness;  // Falloff smoothness
    float vignette_roundness;   // Aspect ratio
    uint _pad5;

    // Quality
    uint dithering;             // 0 or 1
    float dither_strength;      // Dither amount
    uint _pad6;
    uint _pad7;

    // Screen dimensions
    float screen_width;
    float screen_height;
    uint _pad8;
    uint _pad9;
} ubo;

// ============================================================================
// CONSTANTS
// ============================================================================

const float PI = 3.14159265359;
const float EPSILON = 1e-10;

// Luminance weights (Rec. 709 standard)
const vec3 LUMA_WEIGHTS = vec3(0.2126, 0.7152, 0.0722);

// ============================================================================
// UTILITY FUNCTIONS
// ============================================================================

/**
 * @brief Calculate luminance from RGB color
 * Uses Rec. 709 coefficients
 */
float luminance(vec3 color) {
    return dot(color, LUMA_WEIGHTS);
}

/**
 * @brief Convert RGB to HSV color space
 */
vec3 rgb_to_hsv(vec3 rgb) {
    float cmax = max(max(rgb.r, rgb.g), rgb.b);
    float cmin = min(min(rgb.r, rgb.g), rgb.b);
    float delta = cmax - cmin;

    // Hue calculation
    float h = 0.0;
    if (delta > EPSILON) {
        if (cmax == rgb.r) {
            h = mod((rgb.g - rgb.b) / delta, 6.0);
        } else if (cmax == rgb.g) {
            h = (rgb.b - rgb.r) / delta + 2.0;
        } else {
            h = (rgb.r - rgb.g) / delta + 4.0;
        }
        h *= 60.0;
        if (h < 0.0) h += 360.0;
    }

    // Saturation calculation
    float s = (cmax > EPSILON) ? (delta / cmax) : 0.0;

    // Value
    float v = cmax;

    return vec3(h, s, v);
}

/**
 * @brief Convert HSV to RGB color space
 */
vec3 hsv_to_rgb(vec3 hsv) {
    float h = hsv.x;
    float s = hsv.y;
    float v = hsv.z;

    float c = v * s;
    float x = c * (1.0 - abs(mod(h / 60.0, 2.0) - 1.0));
    float m = v - c;

    vec3 rgb;
    if (h < 60.0) {
        rgb = vec3(c, x, 0.0);
    } else if (h < 120.0) {
        rgb = vec3(x, c, 0.0);
    } else if (h < 180.0) {
        rgb = vec3(0.0, c, x);
    } else if (h < 240.0) {
        rgb = vec3(0.0, x, c);
    } else if (h < 300.0) {
        rgb = vec3(x, 0.0, c);
    } else {
        rgb = vec3(c, 0.0, x);
    }

    return rgb + m;
}

/**
 * @brief Pseudo-random number generator for dithering
 * Gold Noise ©2015 dcerisano@standard3d.com
 * - based on the Golden Ratio
 * - uniform normalized distribution
 * - fastest static noise generator function (also runs at low precision)
 */
float gold_noise(vec2 xy, float seed) {
    return fract(tan(distance(xy * 1.61803398875, xy) * seed) * xy.x);
}

// ============================================================================
// TONE MAPPING OPERATORS
// ============================================================================

/**
 * @brief Linear tone mapping (simple clamp)
 * No tone mapping, just clamps to [0,1]
 */
vec3 tone_map_linear(vec3 hdr) {
    return clamp(hdr, 0.0, 1.0);
}

/**
 * @brief Reinhard tone mapping
 * Simple and fast, but can desaturate bright colors
 * Formula: L' = L / (1 + L)
 * Reference: Reinhard et al. 2002
 */
vec3 tone_map_reinhard(vec3 hdr) {
    return hdr / (1.0 + hdr);
}

/**
 * @brief Extended Reinhard tone mapping with white point
 * Allows bright values to approach white smoothly
 * Formula: L' = L(1 + L/Lwhite²) / (1 + L)
 * Reference: Reinhard et al. 2002 (extended formula)
 */
vec3 tone_map_reinhard_extended(vec3 hdr, float white_point) {
    float white_sq = white_point * white_point;
    vec3 numerator = hdr * (1.0 + (hdr / white_sq));
    return numerator / (1.0 + hdr);
}

/**
 * @brief ACES filmic tone mapping (Narkowicz approximation)
 * Academy Color Encoding System - industry standard for film/games
 * Produces natural, film-like colors with proper contrast
 *
 * This is the Narkowicz 2015 approximation of the full ACES RRT+ODT.
 * It's very fast and produces excellent results.
 *
 * Formula:
 *   (x * (a*x + b)) / (x * (c*x + d) + e)
 * where:
 *   a = 2.51, b = 0.03, c = 2.43, d = 0.59, e = 0.14
 *
 * Reference: https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/
 */
vec3 tone_map_aces_narkowicz(vec3 x) {
    const float a = 2.51;
    const float b = 0.03;
    const float c = 2.43;
    const float d = 0.59;
    const float e = 0.14;
    return clamp((x * (a * x + b)) / (x * (c * x + d) + e), 0.0, 1.0);
}

/**
 * @brief Uncharted 2 filmic tone mapping (Hable)
 * Used in Uncharted 2, produces a strong filmic look
 * Good contrast and shoulder (bright areas compress nicely)
 *
 * Reference: http://filmicworlds.com/blog/filmic-tonemapping-operators/
 */
vec3 uncharted2_tonemap_partial(vec3 x) {
    const float A = 0.15;  // Shoulder strength
    const float B = 0.50;  // Linear strength
    const float C = 0.10;  // Linear angle
    const float D = 0.20;  // Toe strength
    const float E = 0.02;  // Toe numerator
    const float F = 0.30;  // Toe denominator
    return ((x * (A * x + C * B) + D * E) / (x * (A * x + B) + D * F)) - E / F;
}

vec3 tone_map_uncharted2(vec3 color) {
    const float W = 11.2;  // Linear white point value
    vec3 curr = uncharted2_tonemap_partial(color);
    vec3 white_scale = vec3(1.0) / uncharted2_tonemap_partial(vec3(W));
    return curr * white_scale;
}

/**
 * @brief Hejl-Dawson filmic approximation (2015)
 * Very fast approximation of filmic curve
 * Good for performance-critical applications
 *
 * Reference: Hejl 2015, "HDR color grading and display in Frostbite"
 */
vec3 tone_map_hejl2015(vec3 hdr) {
    vec3 x = max(vec3(0.0), hdr - 0.004);
    return (x * (6.2 * x + 0.5)) / (x * (6.2 * x + 1.7) + 0.06);
}

/**
 * @brief Apply selected tone mapping operator
 */
vec3 apply_tone_mapping(vec3 hdr) {
    switch (ubo.tone_mapping_mode) {
        case 0:  // Linear
            return tone_map_linear(hdr);
        case 1:  // Reinhard
            return tone_map_reinhard(hdr);
        case 2:  // Reinhard Extended
            return tone_map_reinhard_extended(hdr, ubo.white_point);
        case 3:  // ACES (default, recommended)
            return tone_map_aces_narkowicz(hdr);
        case 4:  // Uncharted 2
            return tone_map_uncharted2(hdr);
        case 5:  // Hejl 2015
            return tone_map_hejl2015(hdr);
        default:
            return tone_map_aces_narkowicz(hdr);
    }
}

// ============================================================================
// COLOR GRADING
// ============================================================================

/**
 * @brief Apply color temperature shift
 * Uses Planckian locus approximation to shift along blue-orange axis
 *
 * Temperature range corresponds to:
 * -1.0 = ~2000K (very blue, cool)
 *  0.0 = ~6500K (neutral, daylight)
 * +1.0 = ~10000K (very orange, warm)
 *
 * Reference: Tanner Helland, "Color Temperature to RGB"
 */
vec3 apply_color_temperature(vec3 color, float temperature) {
    // Convert temperature parameter to Kelvin
    // Map [-1, 1] to [2000K, 10000K] with neutral at 6500K
    float temp_k = 6500.0 + temperature * 4000.0;
    temp_k = clamp(temp_k, 1000.0, 40000.0) / 100.0;

    // Calculate RGB multipliers based on temperature
    vec3 temp_color;

    // Red channel
    if (temp_k <= 66.0) {
        temp_color.r = 1.0;
    } else {
        float t = temp_k - 60.0;
        temp_color.r = 1.29293618606274509804 * pow(t, -0.1332047592);
        temp_color.r = clamp(temp_color.r, 0.0, 1.0);
    }

    // Green channel
    if (temp_k <= 66.0) {
        float t = temp_k;
        temp_color.g = 0.39008157876901960784 * log(t) - 0.63184144378862745098;
    } else {
        float t = temp_k - 60.0;
        temp_color.g = 1.12989086089529411765 * pow(t, -0.0755148492);
    }
    temp_color.g = clamp(temp_color.g, 0.0, 1.0);

    // Blue channel
    if (temp_k >= 66.0) {
        temp_color.b = 1.0;
    } else if (temp_k <= 19.0) {
        temp_color.b = 0.0;
    } else {
        float t = temp_k - 10.0;
        temp_color.b = 0.54320678911019607843 * log(t) - 1.19625408914;
        temp_color.b = clamp(temp_color.b, 0.0, 1.0);
    }

    // Apply temperature shift
    return color * temp_color;
}

/**
 * @brief Apply green/magenta tint
 * Shifts along the orthogonal axis to temperature
 */
vec3 apply_tint(vec3 color, float tint) {
    // Tint affects green channel primarily, with compensation in red/blue
    vec3 tint_color = vec3(1.0);
    if (tint > 0.0) {
        // Magenta (reduce green, boost red/blue slightly)
        tint_color.g = 1.0 - tint * 0.5;
        tint_color.r = 1.0 + tint * 0.1;
        tint_color.b = 1.0 + tint * 0.1;
    } else if (tint < 0.0) {
        // Green (boost green, reduce red/blue slightly)
        tint_color.g = 1.0 + abs(tint) * 0.5;
        tint_color.r = 1.0 - abs(tint) * 0.1;
        tint_color.b = 1.0 - abs(tint) * 0.1;
    }
    return color * tint_color;
}

/**
 * @brief Apply saturation adjustment
 * Interpolates between grayscale and original color
 */
vec3 apply_saturation(vec3 color, float saturation) {
    float luma = luminance(color);
    return mix(vec3(luma), color, saturation);
}

/**
 * @brief Apply vibrance
 * Like saturation, but affects less-saturated colors more
 * Preserves skin tones better than saturation
 */
vec3 apply_vibrance(vec3 color, float vibrance) {
    float luma = luminance(color);
    float max_channel = max(max(color.r, color.g), color.b);
    float min_channel = min(min(color.r, color.g), color.b);
    float sat = max_channel - min_channel;

    // Vibrance effect is stronger on less saturated colors
    float boost = (1.0 - sat) * vibrance;

    return mix(vec3(luma), color, 1.0 + boost);
}

/**
 * @brief Apply contrast adjustment
 * Scales around middle gray (0.5)
 */
vec3 apply_contrast(vec3 color, float contrast) {
    return (color - 0.5) * contrast + 0.5;
}

/**
 * @brief Apply brightness offset
 * Simple additive brightness adjustment
 */
vec3 apply_brightness(vec3 color, float brightness) {
    return color + brightness;
}

/**
 * @brief Apply gamma correction
 * Power function applied to each channel
 */
vec3 apply_gamma(vec3 color, float gamma) {
    return pow(max(color, vec3(0.0)), vec3(1.0 / gamma));
}

/**
 * @brief Apply lift/gamma/gain color correction
 * ASC CDL (American Society of Cinematographers Color Decision List) model
 *
 * Lift:  Affects shadows (dark tones) - additive
 * Gamma: Affects midtones - power function
 * Gain:  Affects highlights (bright tones) - multiplicative
 *
 * This is a standard color grading model used in film and games.
 *
 * Reference: ASC CDL specification
 */
vec3 apply_lift_gamma_gain(vec3 color, vec3 lift, vec3 gamma_color, vec3 gain) {
    // Lift (shadows): offset += lift
    color = color + lift;

    // Gamma (midtones): pow(color, 1/gamma)
    color = pow(max(color, vec3(0.0)), 1.0 / max(gamma_color, vec3(EPSILON)));

    // Gain (highlights): color *= gain
    color = color * gain;

    return color;
}

// ============================================================================
// VIGNETTE
// ============================================================================

/**
 * @brief Apply vignette effect
 * Darkens edges of screen for cinematic look
 *
 * @param color Input color
 * @param uv Screen UV coordinates [0,1]
 * @param intensity Vignette strength (0 to 1)
 * @param smoothness Falloff smoothness (0 to 1)
 * @param roundness Aspect ratio compensation (0 to 1)
 */
vec3 apply_vignette(vec3 color, vec2 uv, float intensity, float smoothness, float roundness) {
    if (intensity <= EPSILON) {
        return color;
    }

    // Center coordinates [-1, 1]
    vec2 centered = uv * 2.0 - 1.0;

    // Apply aspect ratio compensation
    float aspect = ubo.screen_width / ubo.screen_height;
    centered.x *= mix(aspect, 1.0, roundness);

    // Calculate distance from center
    float dist = length(centered);

    // Vignette falloff
    float vignette = smoothstep(1.0, 1.0 - smoothness, dist);
    vignette = mix(1.0, vignette, intensity);

    return color * vignette;
}

// ============================================================================
// DITHERING
// ============================================================================

/**
 * @brief Apply dithering to prevent color banding
 * Uses triangular probability density function (TPDF) for blue noise
 *
 * Dithering breaks up posterization artifacts that occur when
 * converting from high-precision HDR to 8-bit LDR output.
 *
 * Reference: Digital audio/video dithering techniques
 */
vec3 apply_dithering(vec3 color, vec2 screen_pos, float strength) {
    if (ubo.dithering == 0) {
        return color;
    }

    // Generate two random values for TPDF
    float noise1 = gold_noise(screen_pos, 1.0);
    float noise2 = gold_noise(screen_pos, 2.0);

    // TPDF: difference of two uniform random variables
    // This produces triangular distribution centered at 0
    float dither = (noise1 - noise2) * strength;

    // Apply dither to each channel
    return color + dither / 255.0;
}

// ============================================================================
// MAIN COMPUTE SHADER
// ============================================================================

void main() {
    // Get pixel coordinates
    ivec2 pixel_coords = ivec2(gl_GlobalInvocationID.xy);
    ivec2 image_size = ivec2(ubo.screen_width, ubo.screen_height);

    // Early exit if out of bounds
    if (pixel_coords.x >= image_size.x || pixel_coords.y >= image_size.y) {
        return;
    }

    // Calculate UV coordinates [0, 1]
    vec2 uv = (vec2(pixel_coords) + 0.5) / vec2(image_size);

    // Sample HDR input
    vec3 hdr_color = texture(u_hdr_input, uv).rgb;

    // ========================================================================
    // STEP 1: EXPOSURE
    // ========================================================================

    hdr_color *= ubo.exposure;

    // ========================================================================
    // STEP 2: TONE MAPPING (HDR → LDR)
    // ========================================================================

    vec3 ldr_color = apply_tone_mapping(hdr_color);

    // ========================================================================
    // STEP 3: COLOR GRADING
    // ========================================================================

    // Color temperature and tint
    ldr_color = apply_color_temperature(ldr_color, ubo.temperature);
    ldr_color = apply_tint(ldr_color, ubo.tint);

    // Saturation and vibrance
    ldr_color = apply_saturation(ldr_color, ubo.saturation);
    ldr_color = apply_vibrance(ldr_color, ubo.vibrance);

    // Contrast and brightness
    ldr_color = apply_contrast(ldr_color, ubo.contrast);
    ldr_color = apply_brightness(ldr_color, ubo.brightness);

    // ========================================================================
    // STEP 4: LIFT/GAMMA/GAIN (Color Balance)
    // ========================================================================

    ldr_color = apply_lift_gamma_gain(ldr_color, ubo.lift, ubo.gamma_color, ubo.gain);

    // ========================================================================
    // STEP 5: GAMMA CORRECTION
    // ========================================================================

    ldr_color = apply_gamma(ldr_color, ubo.gamma);

    // ========================================================================
    // STEP 6: VIGNETTE
    // ========================================================================

    ldr_color = apply_vignette(ldr_color, uv, ubo.vignette_intensity,
                               ubo.vignette_smoothness, ubo.vignette_roundness);

    // ========================================================================
    // STEP 7: DITHERING
    // ========================================================================

    ldr_color = apply_dithering(ldr_color, vec2(pixel_coords), ubo.dither_strength);

    // ========================================================================
    // FINAL OUTPUT
    // ========================================================================

    // Clamp to [0, 1] and write to output
    ldr_color = clamp(ldr_color, 0.0, 1.0);
    imageStore(u_ldr_output, pixel_coords, vec4(ldr_color, 1.0));
}